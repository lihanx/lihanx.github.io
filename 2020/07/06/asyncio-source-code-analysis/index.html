<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="努力建设中...">
    

    <!--Author-->
    
        <meta name="author" content="Li Hanxuan">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="asyncio源码浅析"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="努力建设中..." />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Li Hanxuan&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>asyncio源码浅析 - Li Hanxuan&#39;s Blog</title>

    <!-- Tachyons Core CSS -->
    <link rel="stylesheet" href="https://unpkg.com/tachyons/css/tachyons.min.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 5.2.0"></head>


<body>

<!-- Main Content -->
<!-- Banner -->
<!-- Banner -->
<div class="w-100 bg-1 ph5-ns ph3 text-light">
    
    <nav class="db dt-l w-100 mw8 center border-box pv3">
        <a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="Li Hanxuan's Blog">
            <img src="http://www.codeblocq.com/assets/projects/hexo-theme-anodyne/assets/anodyne.svg" class="dib h3" alt="Li Hanxuan's Blog">
        </a>
        <div class="db dtc-l v-mid w-100 w-75-l tc tr-l">
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/" 
                    title="首页">
                    首页
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/archives" 
                    title="时间轴">
                    时间轴
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/tags" 
                    title="标签">
                    标签
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" 
                    href="/categories" 
                    title="分类">
                    分类
                </a>
            
        </div>
    </nav>

    <!-- Title -->
    <div class="w-100 mw8 center vh-40 dt">
        <div class="dtc v-mid white">
            <h1 class="f1-l f2-m tc tc-m tl-ns">asyncio源码浅析</h1>
            <p class="f4 fw3 pab-100px tc tc-m tl-ns">2020-07-06</p>
        </div>
    </div>

    <!-- Icon -->
    <div class="relative w-100 mw8 center white dn dn-m db-ns">
        <i class="header-icon fa fa-python"></i>
    </div>
</div>

<!-- Content -->
<div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l">
    <div class="content">
        <div class="mw8 center">
            <div class="cf">
                <div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content">
                    <!-- Tags Vertical -->
                    
                        <div class="tags-container-vertical">
                            <div class="tags-sub-container">
                                <a class="fw3 ph1 dib" href="/tags/Asyncio/">#Asyncio</a> <a class="fw3 ph1 dib" href="/tags/Python/">#Python</a>
                            </div>
                        </div>
                    

                    <!-- Main Post Content -->
                    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一篇笔记会主要从 <code>asyncio</code> 标准库源码的角度，来熟悉 Python 3.7 所提供的异步编程API。同时，尝试着理解和灵活运用 <code>asyncio</code> 所提供的功能。由于涉及到不同平台的实现不同，而我们使用最多的是Linux平台。因此，梳理过程中主要以Linux平台相关实现为主。并且，本篇以理解流程为重点，不会对每一行代码进行分析，相关细节可以在理解流程后再做深入。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>说到 <strong>异步编程</strong> 或者 <code>asyncio</code> ，首先需要对几种I/O模型有些基本的概念。这个在网上已经有了很多的博文，这里就不再赘述。在《Unix网络编程 Vol.1》和《The Linux Programming Interface》中，对I/O模型的特点和相关的系统调用也有详尽的介绍。5类I/O模型如下：</p>
<ul>
<li>阻塞I/O（blocking I/O）</li>
<li>非阻塞I/O（nonblocking I/O）</li>
<li>I/O多路复用（I/O multiplexing）</li>
<li>信号驱动I/O（signal driven I/O）</li>
<li>异步I/O（asynchronous I/O）</li>
</ul>
<p>使用<code>asyncio</code> 进行编程，应用的是I/O多路复用模型，即在单个进程（或线程）中，同时监听多个描述符，实现对进程（或线程）的复用。另外，I/O多路复用模型与非阻塞I/O模型并不是互斥的关系，事实上，它正是基于非阻塞I/O才得以实现的。</p>
<p>通常，我们会更多地在网络编程中用到，而且很多示例都是使用 <code>socket</code> 来介绍的(比如下文的 <code>selectors</code>)，这让我产生了一种错觉：I/O多路复用模型是不是只能应用在网络编程或者socket编程中呢？ 答案是否定的。事实上，通过学习与I/O多路复用相关的系统调用，可以了解到，devices(terminals ans pseudoterminals)、pipes、FIFOs类型，同样支持非阻塞模式。那么自然，I/O多路复用模型也可以用于这些类型的文件描述符监听。</p>
<h2 id="selectors-简介"><a href="#selectors-简介" class="headerlink" title="selectors 简介"></a><code>selectors</code> 简介</h2><p>在总结 <code>asyncio</code> 之前，有必要先了解一下<code>selectors</code>标准库。<code>selectors</code>是在 Python 3.4 版本加入到Python标准库中，旨在提供高效的、high-level的I/O多路复用支持。它是依赖于更 low-level 的<code>select</code>模块实现的。</p>
<p><code>selectors</code>中的类层级关系如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseSelector</span><br><span class="line">    +-- SelectSelector</span><br><span class="line">    +-- PollSelector</span><br><span class="line">    +-- EpollSelector</span><br><span class="line">    +-- DevpollSelector</span><br><span class="line">    +-- KqueueSelector</span><br></pre></td></tr></table></figure>

<p>这其中不同的 “Selector” ，是基于不同平台的实现。当然，<code>selectors</code> 中提供了方便的 <code>DefaultSelector</code> 类，可以根据当前平台自动选择合适的 Selector 类，也是推荐大部分用户直接使用的类。</p>
<p>下面是官方文档中提供的标准示例，理解这个例子非常有助于进一步理解asyncio的逻辑。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()       <span class="comment"># &lt;1&gt; 示例化Selector，根据平台进行选择</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">sock, mask</span>):</span></span><br><span class="line">    conn, addr = sock.accept()  <span class="comment"># Should be ready  &lt;7&gt; 获得客户端连接的描述符</span></span><br><span class="line">    print(<span class="string">&#x27;accepted&#x27;</span>, conn, <span class="string">&#x27;from&#x27;</span>, addr)</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>)     <span class="comment"># &lt;8&gt; 设置为非阻塞模式</span></span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)      <span class="comment"># &lt;9&gt; 绑定事件和回调函数，将描述符注册到selector上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">conn, mask</span>):</span></span><br><span class="line">    data = conn.recv(<span class="number">1000</span>)  <span class="comment"># Should be ready</span></span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        print(<span class="string">&#x27;echoing&#x27;</span>, <span class="built_in">repr</span>(data), <span class="string">&#x27;to&#x27;</span>, conn)</span><br><span class="line">        conn.send(data)  <span class="comment"># Hope it won&#x27;t block</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;closing&#x27;</span>, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()      <span class="comment"># &lt;2&gt; 获得socket实例</span></span><br><span class="line">sock.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">1234</span>))      <span class="comment"># &lt;3&gt; 服务端，绑定地址，监听链接</span></span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)     <span class="comment"># &lt;4&gt;  设置为非阻塞模式</span></span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)        <span class="comment"># &lt;5&gt; 将socket实例和回调函数，绑定事件，注册到selector中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:             <span class="comment"># &lt;6&gt; 开启事件循环，在每一轮循环中阻塞在select调用处，等待事件触发返回可用描述符</span></span><br><span class="line">    events = sel.select()</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)  <span class="comment"># 调用回调函数</span></span><br></pre></td></tr></table></figure>



<p>根据这个简单的例子，其中有几个关键的对象和步骤：</p>
<p><strong>对象：</strong></p>
<ul>
<li>文件描述符（file descriptor）-  <code>conn</code> <code>sock</code></li>
<li>回调函数（callback） - <code>accept()</code> <code>read()</code></li>
<li>事件循环 (event loop) - <code>while: ...</code></li>
</ul>
<p><strong>过程：</strong></p>
<ul>
<li>设置非阻塞模式 - <code>fd.setblocking(False)</code></li>
<li>注册描述符 - <code>sel.register(fd, event, callback)</code></li>
</ul>
<p>这是一个最简单的I/O多路复用模式的雏形。在分析 <code>asyncio</code> 源码的过程中，始终记住这个模板，并且尝试的把不同角色对应起来，对理解<code>asyncio</code>复杂的调度会非常有帮助。那么接下来就进入正题。</p>
<h2 id="asyncio-源码浅析"><a href="#asyncio-源码浅析" class="headerlink" title="asyncio 源码浅析"></a><code>asyncio</code> 源码浅析</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">asyncio</span><br><span class="line">    + —— __init__.py</span><br><span class="line">    + —— base_events.py</span><br><span class="line">    + —— base_futures.py</span><br><span class="line">    + —— base_subprocess.py</span><br><span class="line">    + —— base_tasks.py</span><br><span class="line">    + —— constants.py</span><br><span class="line">    + —— coroutines.py</span><br><span class="line">    + —— events.py</span><br><span class="line">    + —— format_helpers.py</span><br><span class="line">    + —— futures.py</span><br><span class="line">    + —— locks.py</span><br><span class="line">    + —— log.py</span><br><span class="line">    + —— proactor_events.py</span><br><span class="line">    + —— protocols.py</span><br><span class="line">    + —— queues.py</span><br><span class="line">    + —— runners.py</span><br><span class="line">    + —— selector_events.py</span><br><span class="line">    + —— sslproto.py</span><br><span class="line">    + —— streams.py</span><br><span class="line">    + —— subprocess.py</span><br><span class="line">    + —— tasks.py</span><br><span class="line">    + —— transports.py</span><br><span class="line">    + —— unix_events.py</span><br><span class="line">    + —— windows_events.py</span><br><span class="line">    + —— windows_utils.py</span><br></pre></td></tr></table></figure>



<p>为了快速的了解 <code>asyncio</code> 的基本工作模式，这里选择暂时忽略一些内容，只提取其中涉及到调度的核心部分来进行分析。</p>
<p>那么，挑挑拣拣，剩下一些主要模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asyncio</span><br><span class="line">    + —— __init__.py</span><br><span class="line">    + —— base_events.py</span><br><span class="line">    + —— base_futures.py</span><br><span class="line">    + —— base_tasks.py</span><br><span class="line">    + —— events.py</span><br><span class="line">    + —— futures.py</span><br><span class="line">    + —— proactor_events.py</span><br><span class="line">    + —— runners.py</span><br><span class="line">    + —— selector_events.py</span><br><span class="line">    + —— tasks.py</span><br><span class="line">    + —— unix_events.py</span><br><span class="line">    + —— windows_events.py</span><br></pre></td></tr></table></figure>


<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p><strong><code>EventLoop</code></strong></p>
<p>相关文件: <code>events.py</code>, <code>base_events.py</code>, <code>selector_events.py</code>, <code>windows_events.py</code>, <code>proactor_events.py</code></p>
<p>由上面 <code>selectors</code> 的示例可以看出，最终的 <code>while</code> 循环是使得整个逻辑运行起来的核心。在<code>asyncio</code> 中，事件循环被抽象为一系列的类，它负责了异步任务、回调函数的执行，进行网络I/O操作和子进程的运行等，是基于<code>asyncio</code>的应用的核心。根据不同平台，有不同的子类实现，继承关系如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AbstractEventLoop</span><br><span class="line">    |</span><br><span class="line">    + —— BaseEventLoop</span><br><span class="line">            |</span><br><span class="line">            + —— BaseSelectorEventLoop</span><br><span class="line">            |        |</span><br><span class="line">            |        + —— _UnixSelectorEventLoop</span><br><span class="line">            |        |</span><br><span class="line">            |        + —— _WindowsSelectorEventLoop</span><br><span class="line">            |</span><br><span class="line">            + —— BaseProactorEventLoop</span><br><span class="line">                     |</span><br><span class="line">                     + —— ProactorEventLoop</span><br></pre></td></tr></table></figure>

<p>首先，对于我们最常用的 <code>loop.run_until_complete()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span>(<span class="params">events.AbstractEventLoop</span>):</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span>(<span class="params">self, future</span>):</span></span><br><span class="line">        self._check_closed()</span><br><span class="line"></span><br><span class="line">        new_task = <span class="keyword">not</span> futures.isfuture(future)</span><br><span class="line">        future = tasks.ensure_future(future, loop=self)</span><br><span class="line">        <span class="keyword">if</span> new_task:</span><br><span class="line">            future._log_destroy_pending = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        future.add_done_callback(_run_until_complete_cb)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run_forever()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span> new_task <span class="keyword">and</span> future.done() <span class="keyword">and</span> <span class="keyword">not</span> future.cancelled():</span><br><span class="line">                future.exception()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            future.remove_done_callback(_run_until_complete_cb)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> future.done():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Event loop stopped before Future completed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> future.result()</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>run_until_complete()</code>方法其实是通过 <code>run_forever()</code>方法和 <code>_run_until_complete_cb()</code> 这个回调函数来实现运行完成后终止的。<br>回调函数通过 <code>futurn.add_done_callback()</code> 来进行添加。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_until_complete_cb</span>(<span class="params">fut</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fut.cancelled():</span><br><span class="line">        exc = fut.exception()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc, BaseException) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(exc, Exception):</span><br><span class="line">            <span class="comment"># Issue #22429: run_forever() already finished, no need to</span></span><br><span class="line">            <span class="comment"># stop it.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    futures._get_loop(fut).stop()</span><br></pre></td></tr></table></figure>

<p>这个回调函数，在 <code>fut</code> 执行结束后，最关键的一步，获取到它的事件循环，并调用 <code>stop()</code> 方法将其停止。</p>
<p><code>run_forever()</code> 的源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span>(<span class="params">events.AbstractEventLoop</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run until stop() is called.&quot;&quot;&quot;</span></span><br><span class="line">        self._check_closed()</span><br><span class="line">        <span class="keyword">if</span> self.is_running():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;This event loop is already running&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> events._get_running_loop() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">&#x27;Cannot run the event loop while another loop is running&#x27;</span>)</span><br><span class="line">        self._set_coroutine_origin_tracking(self._debug)</span><br><span class="line">        self._thread_id = threading.get_ident()</span><br><span class="line"></span><br><span class="line">        old_agen_hooks = sys.get_asyncgen_hooks()</span><br><span class="line">        sys.set_asyncgen_hooks(firstiter=self._asyncgen_firstiter_hook,</span><br><span class="line">                               finalizer=self._asyncgen_finalizer_hook)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            events._set_running_loop(self)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                self._run_once()</span><br><span class="line">                <span class="keyword">if</span> self._stopping:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._stopping = <span class="literal">False</span></span><br><span class="line">            self._thread_id = <span class="literal">None</span></span><br><span class="line">            events._set_running_loop(<span class="literal">None</span>)</span><br><span class="line">            self._set_coroutine_origin_tracking(<span class="literal">False</span>)</span><br><span class="line">            sys.set_asyncgen_hooks(*old_agen_hooks)</span><br></pre></td></tr></table></figure>

<p>回想开篇 <code>selectors</code> 的示例，在这里首先对应上了第一个关键结构：事件循环 <code>while ...</code></p>
<p>显然，如果我们调用 <code>run_forever()</code>方法，事件循环将会永远的运行下去，除非强制中断。在实际的应用中，我们就不能像使用 <code>run_until_complete()</code> 时，还将一部分代码功能留在“外部”，我们应该预先定义基于任务与回调的代码逻辑，让事件循环来完成调用执行工作，在运行代码的最后一步，调用<code>run_forever()</code>启动事件循环，使程序持续运转起来。</p>
<p><em>To Be Continued</em></p>

                    
                    <!-- Tags Bottom -->
                    
                        <div class="tags-container-bottom">
                            <i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/Asyncio/">#Asyncio</a> <a class="fw3 ph1 dib" href="/tags/Python/">#Python</a>
                        </div>
                    

                    <!-- Comments -->
                    



                </div>
                <div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50">
                    
                    <hr class="dn-l mw4 black-50 mt5" />
                    
                    <!-- Widget 1: About -->
                    <div class="mt5 mt0-l">
    <article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3">
        <div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width: 6rem;">
            <img src="/images/profile.png" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="Li Hanxuan">
        </div>
        <div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">
            
        </div>
    </article>
</div>

                    <hr class="dn-l mw4 black-50 mt5" />
                    
                    <!-- Widget 2: Categories -->
                    
                        <div class="mt5 tc tl-l">
    <h3>Categories</h3>
    
        <p>
            <a href="/categories/Python/">Python</a>
        </p>
    
</div>


                        <hr class="dn-l mw4 black-50 mt5" />
                    

                    <!-- Widget 3: Recent Posts -->
                    <div class="mt5 tc tl-l">
    <h3>Recent Posts</h3>
    
        <p>
            <a href="/2020/09/15/setting-up-a-k8s-cluster-with-vm/">使用 Virtualbox 创建 VM k8s 集群</a>
        </p>
    
        <p>
            <a href="/2020/07/06/asyncio-source-code-analysis/">asyncio源码浅析</a>
        </p>
    
        <p>
            <a href="/2020/03/21/thread-implementation-models/">线程实现模型(Thread Implementation models)</a>
        </p>
    
        <p>
            <a href="/2019/12/05/system-calls/">Linux系统调用(System Calls)流程</a>
        </p>
    
        <p>
            <a href="/2019/09/24/the-run-time-storage-organization/">运行时的内存管理</a>
        </p>
    
</div>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Footer -->
<div class="bg-1 ph2 ph5-ns pv5">
        <div class="mv8">
            <div class="center tc">
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://github.com/lihanx" target="_blank">
                            <i class="fa fa-github"></i>
                        </a>
                    </div>
                
            </div>
            <div class="f6 f5-ns center tc white pt5 fw3">
                
            </div>
        </div>
    </div>

<!-- After Footer -->
<!-- Disqus Comments -->



</body>

</html>