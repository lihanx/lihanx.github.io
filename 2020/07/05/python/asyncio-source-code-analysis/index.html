<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="前言这一篇笔记会主要从 asyncio 标准库源码的角度，来熟悉 Python 3.7 所提供的异步编程API。同时，尝试着理解和灵活运用 asyncio 所提供的功能。由于涉及到不同平台的实现不同，而我们使用最多的是Linux平台。因此，梳理过程中主要以Linux平台相关实现为主。并且，本篇以理解流程为重点，不会对每一行代码进行分析，相关细节可以在理解流程后再做深入。 概念I&#x2F;O模型说到 异">
<meta property="og:type" content="article">
<meta property="og:title" content="asyncio源码浅析（一）- 事件循环(EventLoop)">
<meta property="og:url" content="https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/">
<meta property="og:site_name" content="技术与生活">
<meta property="og:description" content="前言这一篇笔记会主要从 asyncio 标准库源码的角度，来熟悉 Python 3.7 所提供的异步编程API。同时，尝试着理解和灵活运用 asyncio 所提供的功能。由于涉及到不同平台的实现不同，而我们使用最多的是Linux平台。因此，梳理过程中主要以Linux平台相关实现为主。并且，本篇以理解流程为重点，不会对每一行代码进行分析，相关细节可以在理解流程后再做深入。 概念I&#x2F;O模型说到 异">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-05T16:00:00.000Z">
<meta property="article:modified_time" content="2022-07-26T06:40:41.442Z">
<meta property="article:author" content="李瀚翾">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Asyncio">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>asyncio源码浅析（一）- 事件循环(EventLoop)</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.2.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/tags/">Tags</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2020/09/14/setting-up-a-k8s-cluster-with-vm/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2020/03/20/linux/thread-implementation-models/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&text=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&is_video=false&description=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=asyncio源码浅析（一）- 事件循环(EventLoop)&body=Check out this article: https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&name=asyncio源码浅析（一）- 事件循环(EventLoop)&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&t=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">I&#x2F;O模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selectors-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">selectors 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asyncio-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">asyncio 源码浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">核心类</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        asyncio源码浅析（一）- 事件循环(EventLoop)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">李瀚翾</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-07-05T16:00:00.000Z" itemprop="datePublished">2020-07-06</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Python/">Python</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Asyncio/" rel="tag">Asyncio</a>, <a class="tag-link-link" href="/tags/Python/" rel="tag">Python</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <a id="more"></a>
<!-- excerpt -->
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一篇笔记会主要从 <code>asyncio</code> 标准库源码的角度，来熟悉 Python 3.7 所提供的异步编程API。同时，尝试着理解和灵活运用 <code>asyncio</code> 所提供的功能。由于涉及到不同平台的实现不同，而我们使用最多的是Linux平台。因此，梳理过程中主要以Linux平台相关实现为主。并且，本篇以理解流程为重点，不会对每一行代码进行分析，相关细节可以在理解流程后再做深入。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>说到 <strong>异步编程</strong> 或者 <code>asyncio</code> ，首先需要对几种I/O模型有些基本的概念。这个在网上已经有了很多的博文，这里就不再赘述。在《Unix网络编程 Vol.1》和《The Linux Programming Interface》中，对I/O模型的特点和相关的系统调用也有详尽的介绍。5类I/O模型如下：</p>
<ul>
<li>阻塞I/O（blocking I/O）</li>
<li>非阻塞I/O（nonblocking I/O）</li>
<li>I/O多路复用（I/O multiplexing）</li>
<li>信号驱动I/O（signal driven I/O）</li>
<li>异步I/O（asynchronous I/O）</li>
</ul>
<p>使用<code>asyncio</code> 进行编程，应用的是I/O多路复用模型，即在单个进程（或线程）中，同时监听多个描述符，实现对进程（或线程）的复用。另外，I/O多路复用模型与非阻塞I/O模型并不是互斥的关系，事实上，它正是基于非阻塞I/O才得以实现的。</p>
<p>通常，我们会更多地在网络编程中用到，而且很多示例都是使用 <code>socket</code> 来介绍的(比如下文的 <code>selectors</code>)，这让我产生了一种错觉：I/O多路复用模型是不是只能应用在网络编程或者socket编程中呢？ 答案是否定的。事实上，通过学习与I/O多路复用相关的系统调用，可以了解到，devices(terminals ans pseudoterminals)、pipes、FIFOs类型，同样支持非阻塞模式。那么自然，I/O多路复用模型也可以用于这些类型的文件描述符监听。</p>
<h2 id="selectors-简介"><a href="#selectors-简介" class="headerlink" title="selectors 简介"></a><code>selectors</code> 简介</h2><p>在总结 <code>asyncio</code> 之前，有必要先了解一下<code>selectors</code>标准库。<code>selectors</code>是在 Python 3.4 版本加入到Python标准库中，旨在提供高效的、high-level的I/O多路复用支持。它是依赖于更 low-level 的<code>select</code>模块实现的。</p>
<p><code>selectors</code>中的类层级关系如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseSelector</span><br><span class="line">    +-- SelectSelector</span><br><span class="line">    +-- PollSelector</span><br><span class="line">    +-- EpollSelector</span><br><span class="line">    +-- DevpollSelector</span><br><span class="line">    +-- KqueueSelector</span><br></pre></td></tr></table></figure>
<p>这其中不同的 “Selector” ，是基于不同平台的实现。当然，<code>selectors</code> 中提供了方便的 <code>DefaultSelector</code> 类，可以根据当前平台自动选择合适的 Selector 类，也是推荐大部分用户直接使用的类。</p>
<p>下面是官方文档中提供的标准示例，理解这个例子非常有助于进一步理解asyncio的逻辑。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()       <span class="comment"># &lt;1&gt; 示例化Selector，根据平台进行选择</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">sock, mask</span>):</span></span><br><span class="line">    conn, addr = sock.accept()  <span class="comment"># Should be ready  &lt;7&gt; 获得客户端连接的描述符</span></span><br><span class="line">    print(<span class="string">&#x27;accepted&#x27;</span>, conn, <span class="string">&#x27;from&#x27;</span>, addr)</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>)     <span class="comment"># &lt;8&gt; 设置为非阻塞模式</span></span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)      <span class="comment"># &lt;9&gt; 绑定事件和回调函数，将描述符注册到selector上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">conn, mask</span>):</span></span><br><span class="line">    data = conn.recv(<span class="number">1000</span>)  <span class="comment"># Should be ready</span></span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        print(<span class="string">&#x27;echoing&#x27;</span>, <span class="built_in">repr</span>(data), <span class="string">&#x27;to&#x27;</span>, conn)</span><br><span class="line">        conn.send(data)  <span class="comment"># Hope it won&#x27;t block</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;closing&#x27;</span>, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()      <span class="comment"># &lt;2&gt; 获得socket实例</span></span><br><span class="line">sock.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">1234</span>))      <span class="comment"># &lt;3&gt; 服务端，绑定地址，监听链接</span></span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)     <span class="comment"># &lt;4&gt;  设置为非阻塞模式</span></span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)        <span class="comment"># &lt;5&gt; 将socket实例和回调函数，绑定事件，注册到selector中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:             <span class="comment"># &lt;6&gt; 开启事件循环，在每一轮循环中阻塞在select调用处，等待事件触发返回可用描述符</span></span><br><span class="line">    events = sel.select()</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)  <span class="comment"># 调用回调函数</span></span><br></pre></td></tr></table></figure>
<p>根据这个简单的例子，其中有几个关键的对象和步骤：</p>
<p><strong>对象：</strong></p>
<ul>
<li>文件描述符（file descriptor）-  <code>conn</code> <code>sock</code></li>
<li>回调函数（callback） - <code>accept()</code> <code>read()</code></li>
<li>事件循环 (event loop) - <code>while: ...</code></li>
</ul>
<p><strong>过程：</strong></p>
<ul>
<li>设置非阻塞模式 - <code>fd.setblocking(False)</code></li>
<li>注册描述符 - <code>sel.register(fd, event, callback)</code></li>
</ul>
<p>这是一个最简单的I/O多路复用模式的雏形。在分析 <code>asyncio</code> 源码的过程中，始终记住这个模板，并且尝试的把不同角色对应起来，对理解<code>asyncio</code>复杂的调度会非常有帮助。那么接下来就进入正题。</p>
<h2 id="asyncio-源码浅析"><a href="#asyncio-源码浅析" class="headerlink" title="asyncio 源码浅析"></a><code>asyncio</code> 源码浅析</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">asyncio</span><br><span class="line">    + —— __init__.py</span><br><span class="line">    + —— base_events.py</span><br><span class="line">    + —— base_futures.py</span><br><span class="line">    + —— base_subprocess.py</span><br><span class="line">    + —— base_tasks.py</span><br><span class="line">    + —— constants.py</span><br><span class="line">    + —— coroutines.py</span><br><span class="line">    + —— events.py</span><br><span class="line">    + —— format_helpers.py</span><br><span class="line">    + —— futures.py</span><br><span class="line">    + —— locks.py</span><br><span class="line">    + —— log.py</span><br><span class="line">    + —— proactor_events.py</span><br><span class="line">    + —— protocols.py</span><br><span class="line">    + —— queues.py</span><br><span class="line">    + —— runners.py</span><br><span class="line">    + —— selector_events.py</span><br><span class="line">    + —— sslproto.py</span><br><span class="line">    + —— streams.py</span><br><span class="line">    + —— subprocess.py</span><br><span class="line">    + —— tasks.py</span><br><span class="line">    + —— transports.py</span><br><span class="line">    + —— unix_events.py</span><br><span class="line">    + —— windows_events.py</span><br><span class="line">    + —— windows_utils.py</span><br></pre></td></tr></table></figure>
<p>为了快速的了解 <code>asyncio</code> 的基本工作模式，这里选择暂时忽略一些内容，只提取其中涉及到调度的核心部分来进行分析。</p>
<p>那么，挑挑拣拣，剩下一些主要模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asyncio</span><br><span class="line">    + —— __init__.py</span><br><span class="line">    + —— base_events.py</span><br><span class="line">    + —— base_futures.py</span><br><span class="line">    + —— base_tasks.py</span><br><span class="line">    + —— events.py</span><br><span class="line">    + —— futures.py</span><br><span class="line">    + —— proactor_events.py</span><br><span class="line">    + —— runners.py</span><br><span class="line">    + —— selector_events.py</span><br><span class="line">    + —— tasks.py</span><br><span class="line">    + —— unix_events.py</span><br><span class="line">    + —— windows_events.py</span><br></pre></td></tr></table></figure>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p><strong><code>EventLoop</code></strong></p>
<p>相关文件: <code>events.py</code>, <code>base_events.py</code>, <code>selector_events.py</code>, <code>windows_events.py</code>, <code>proactor_events.py</code></p>
<p>由上面 <code>selectors</code> 的示例可以看出，最终的 <code>while</code> 循环是使得整个逻辑运行起来的核心。在<code>asyncio</code> 中，事件循环被抽象为一系列的类，它负责了异步任务、回调函数的执行，进行网络I/O操作和子进程的运行等，是基于<code>asyncio</code>的应用的核心。根据不同平台，有不同的子类实现，继承关系如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AbstractEventLoop</span><br><span class="line">    |</span><br><span class="line">    + —— BaseEventLoop</span><br><span class="line">            |</span><br><span class="line">            + —— BaseSelectorEventLoop</span><br><span class="line">            |        |</span><br><span class="line">            |        + —— _UnixSelectorEventLoop</span><br><span class="line">            |        |</span><br><span class="line">            |        + —— _WindowsSelectorEventLoop</span><br><span class="line">            |</span><br><span class="line">            + —— BaseProactorEventLoop</span><br><span class="line">                     |</span><br><span class="line">                     + —— ProactorEventLoop</span><br></pre></td></tr></table></figure>
<p>首先，对于我们最常用的 <code>loop.run_until_complete()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span>(<span class="params">events.AbstractEventLoop</span>):</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span>(<span class="params">self, future</span>):</span></span><br><span class="line">        self._check_closed()</span><br><span class="line"></span><br><span class="line">        new_task = <span class="keyword">not</span> futures.isfuture(future)</span><br><span class="line">        future = tasks.ensure_future(future, loop=self)</span><br><span class="line">        <span class="keyword">if</span> new_task:</span><br><span class="line">            future._log_destroy_pending = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        future.add_done_callback(_run_until_complete_cb)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run_forever()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span> new_task <span class="keyword">and</span> future.done() <span class="keyword">and</span> <span class="keyword">not</span> future.cancelled():</span><br><span class="line">                future.exception()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            future.remove_done_callback(_run_until_complete_cb)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> future.done():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Event loop stopped before Future completed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> future.result()</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>run_until_complete()</code>方法其实是通过 <code>run_forever()</code>方法和 <code>_run_until_complete_cb()</code> 这个回调函数来实现运行完成后终止的。<br>回调函数通过 <code>futurn.add_done_callback()</code> 来进行添加。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_until_complete_cb</span>(<span class="params">fut</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fut.cancelled():</span><br><span class="line">        exc = fut.exception()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc, BaseException) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(exc, Exception):</span><br><span class="line">            <span class="comment"># Issue #22429: run_forever() already finished, no need to</span></span><br><span class="line">            <span class="comment"># stop it.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    futures._get_loop(fut).stop()</span><br></pre></td></tr></table></figure>
<p>这个回调函数，在 <code>fut</code> 执行结束后，最关键的一步，获取到它的事件循环，并调用 <code>stop()</code> 方法将其停止。</p>
<p><code>run_forever()</code> 的源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span>(<span class="params">events.AbstractEventLoop</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run until stop() is called.&quot;&quot;&quot;</span></span><br><span class="line">        self._check_closed()</span><br><span class="line">        <span class="keyword">if</span> self.is_running():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;This event loop is already running&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> events._get_running_loop() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">&#x27;Cannot run the event loop while another loop is running&#x27;</span>)</span><br><span class="line">        self._set_coroutine_origin_tracking(self._debug)</span><br><span class="line">        self._thread_id = threading.get_ident()</span><br><span class="line"></span><br><span class="line">        old_agen_hooks = sys.get_asyncgen_hooks()</span><br><span class="line">        sys.set_asyncgen_hooks(firstiter=self._asyncgen_firstiter_hook,</span><br><span class="line">                               finalizer=self._asyncgen_finalizer_hook)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            events._set_running_loop(self)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                self._run_once()</span><br><span class="line">                <span class="keyword">if</span> self._stopping:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._stopping = <span class="literal">False</span></span><br><span class="line">            self._thread_id = <span class="literal">None</span></span><br><span class="line">            events._set_running_loop(<span class="literal">None</span>)</span><br><span class="line">            self._set_coroutine_origin_tracking(<span class="literal">False</span>)</span><br><span class="line">            sys.set_asyncgen_hooks(*old_agen_hooks)</span><br></pre></td></tr></table></figure></p>
<p>回想开篇 <code>selectors</code> 的示例，在这里首先对应上了第一个关键结构：事件循环 <code>while ...</code></p>
<p>显然，如果我们调用 <code>run_forever()</code>方法，事件循环将会永远的运行下去，除非强制中断。在实际的应用中，我们就不能像使用 <code>run_until_complete()</code> 时，还将一部分代码功能留在“外部”，我们应该预先定义基于任务与回调的代码逻辑，让事件循环来完成调用执行工作，在运行代码的最后一步，调用<code>run_forever()</code>启动事件循环，使程序持续运转起来。</p>
<p>在这个核心的循环中，可以看到，当 <code>_stopping</code> 被设置成 <code>False</code> 时，循环立即退出；否则，每一轮循环，调用一次 <code>_run_once()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    self._run_once()</span><br><span class="line">    <span class="keyword">if</span> self._stopping:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>接下来进入到 <code>_run_once()</code> 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span>(<span class="params">events.AbstractEventLoop</span>):</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_once</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run one full iteration of the event loop.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This calls all currently ready callbacks, polls for I/O,</span></span><br><span class="line"><span class="string">        schedules the resulting callbacks, and finally schedules</span></span><br><span class="line"><span class="string">        &#x27;call_later&#x27; callbacks.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        sched_count = <span class="built_in">len</span>(self._scheduled)</span><br><span class="line">        <span class="keyword">if</span> (sched_count &gt; _MIN_SCHEDULED_TIMER_HANDLES <span class="keyword">and</span></span><br><span class="line">            self._timer_cancelled_count / sched_count &gt;</span><br><span class="line">                _MIN_CANCELLED_TIMER_HANDLES_FRACTION):</span><br><span class="line">            <span class="comment"># Remove delayed calls that were cancelled if their number</span></span><br><span class="line">            <span class="comment"># is too high</span></span><br><span class="line">            new_scheduled = []</span><br><span class="line">            <span class="keyword">for</span> handle <span class="keyword">in</span> self._scheduled:</span><br><span class="line">                <span class="keyword">if</span> handle._cancelled:</span><br><span class="line">                    handle._scheduled = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_scheduled.append(handle)</span><br><span class="line"></span><br><span class="line">            heapq.heapify(new_scheduled)</span><br><span class="line">            self._scheduled = new_scheduled</span><br><span class="line">            self._timer_cancelled_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Remove delayed calls that were cancelled from head of queue.</span></span><br><span class="line">            <span class="keyword">while</span> self._scheduled <span class="keyword">and</span> self._scheduled[<span class="number">0</span>]._cancelled:</span><br><span class="line">                self._timer_cancelled_count -= <span class="number">1</span></span><br><span class="line">                handle = heapq.heappop(self._scheduled)</span><br><span class="line">                handle._scheduled = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        timeout = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self._ready <span class="keyword">or</span> self._stopping:</span><br><span class="line">            timeout = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> self._scheduled:</span><br><span class="line">            <span class="comment"># Compute the desired timeout.</span></span><br><span class="line">            when = self._scheduled[<span class="number">0</span>]._when</span><br><span class="line">            timeout = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">0</span>, when - self.time()), MAXIMUM_SELECT_TIMEOUT)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._debug <span class="keyword">and</span> timeout != <span class="number">0</span>:</span><br><span class="line">            t0 = self.time()</span><br><span class="line">            event_list = self._selector.select(timeout)</span><br><span class="line">            dt = self.time() - t0</span><br><span class="line">            <span class="keyword">if</span> dt &gt;= <span class="number">1.0</span>:</span><br><span class="line">                level = logging.INFO</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                level = logging.DEBUG</span><br><span class="line">            nevent = <span class="built_in">len</span>(event_list)</span><br><span class="line">            <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                logger.log(level, <span class="string">&#x27;poll took %.3f ms: %s events&#x27;</span>,</span><br><span class="line">                           dt * <span class="number">1e3</span>, nevent)</span><br><span class="line">            <span class="keyword">elif</span> nevent:</span><br><span class="line">                logger.log(level,</span><br><span class="line">                           <span class="string">&#x27;poll %.3f ms took %.3f ms: %s events&#x27;</span>,</span><br><span class="line">                           timeout * <span class="number">1e3</span>, dt * <span class="number">1e3</span>, nevent)</span><br><span class="line">            <span class="keyword">elif</span> dt &gt;= <span class="number">1.0</span>:</span><br><span class="line">                logger.log(level,</span><br><span class="line">                           <span class="string">&#x27;poll %.3f ms took %.3f ms: timeout&#x27;</span>,</span><br><span class="line">                           timeout * <span class="number">1e3</span>, dt * <span class="number">1e3</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event_list = self._selector.select(timeout)</span><br><span class="line">        self._process_events(event_list)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Handle &#x27;later&#x27; callbacks that are ready.</span></span><br><span class="line">        end_time = self.time() + self._clock_resolution</span><br><span class="line">        <span class="keyword">while</span> self._scheduled:</span><br><span class="line">            handle = self._scheduled[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> handle._when &gt;= end_time:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            handle = heapq.heappop(self._scheduled)</span><br><span class="line">            handle._scheduled = <span class="literal">False</span></span><br><span class="line">            self._ready.append(handle)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This is the only place where callbacks are actually *called*.</span></span><br><span class="line">        <span class="comment"># All other places just add them to ready.</span></span><br><span class="line">        <span class="comment"># Note: We run all currently scheduled callbacks, but not any</span></span><br><span class="line">        <span class="comment"># callbacks scheduled by callbacks run this time around --</span></span><br><span class="line">        <span class="comment"># they will be run the next time (after another I/O poll).</span></span><br><span class="line">        <span class="comment"># Use an idiom that is thread-safe without using locks.</span></span><br><span class="line">        ntodo = <span class="built_in">len</span>(self._ready)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ntodo):</span><br><span class="line">            handle = self._ready.popleft()</span><br><span class="line">            <span class="keyword">if</span> handle._cancelled:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self._debug:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self._current_handle = handle</span><br><span class="line">                    t0 = self.time()</span><br><span class="line">                    handle._run()</span><br><span class="line">                    dt = self.time() - t0</span><br><span class="line">                    <span class="keyword">if</span> dt &gt;= self.slow_callback_duration:</span><br><span class="line">                        logger.warning(<span class="string">&#x27;Executing %s took %.3f seconds&#x27;</span>,</span><br><span class="line">                                       _format_handle(handle), dt)</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    self._current_handle = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                handle._run()</span><br><span class="line">        handle = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>从上到下看了一遍，有几个问题需要继续思考一下：</p>
<ol>
<li>前面都没有遇到 <code>self._scheduled</code>, 为什么这里看上去需要 <code>self._scheduled</code> 里面有值才行？ <code>self_scheduled</code> 到底是在什么位置被添加进了值呢？</li>
<li><code>self._selector.select(timeout)</code> 在这里直接等待事件触发返回描述符，并且后续调用 <code>self._process_events(event_list)</code> 处理获取到的描述符。那么，这些描述符，不论是Socket描述符，还是其他类型的描述符，又是在什么地方被注册到 <code>self._selector</code> 中的呢？</li>
</ol>
<p>下一篇笔记，我们从一个实例出发，开始寻找这两个问题的答案。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">I&#x2F;O模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selectors-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">selectors 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asyncio-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">asyncio 源码浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">核心类</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&text=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&is_video=false&description=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=asyncio源码浅析（一）- 事件循环(EventLoop)&body=Check out this article: https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&title=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&name=asyncio源码浅析（一）- 事件循环(EventLoop)&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://lihanx.github.io/2020/07/05/python/asyncio-source-code-analysis/&t=asyncio源码浅析（一）- 事件循环(EventLoop)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2022
    李瀚翾
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/tags/">Tags</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
