<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>M42/M43 猎户座星云</title>
      <link href="/2022/10/17/astro-photography/2022-10-17-messier-42/"/>
      <url>/2022/10/17/astro-photography/2022-10-17-messier-42/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><p><img src="kstars.jpeg" alt=""></p><p><br/></p><p><img src="raw_sample.jpeg" alt=""></p><p><br/></p><p><img src="m42-1.jpeg" alt=""></p><p><br/></p><p><img src="m42-2.jpeg" alt=""></p><p>主镜: SkyRover 80 APO Pro<br>赤道仪: EXOS-2 + Onstep<br>主控: Astroberry(Raspberry Pi) + Kstars<br>相机: Nikon D700<br>时间: 2022-10-17 凌晨<br>地点: 南阳台<br>总曝光时长: 约 5 分钟<br>ISO: 100/400/800/1000<br>光污染等级: 6 级</p><blockquote><ol><li>拆掉 EXOS-2 原厂的 Bresser GOTO 后，更换为 Onstep 套件  </li><li>使用 Astroberry 进行 Onstep 和 D700 的控制  </li><li>使用 Kstars + Ekos 客户端连接 Astroberry 的热点进行远程控制  </li><li>经过测试发现 Onstep 必须每次使用手机 APP 初始化 Park Position 和 时间地点，电机才可以启动  </li><li>搭建好整套系统后第一次使用，在阳台的观测窗口又比较短，比较手忙脚乱  </li><li>虽然存在一些小问题，但是整体的使用体验还是非常不错的  </li><li>总曝光时长比较短，所以拍得不是很完整，只能说勉强拍到  </li><li>下一次好天气出摊，争取把曝光时长增加到 1 小时以上  </li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准满月(十四)</title>
      <link href="/2022/09/10/astro-photography/2022-09-09-the-full-moon-at-mid-autumn-festival-night/"/>
      <url>/2022/09/10/astro-photography/2022-09-09-the-full-moon-at-mid-autumn-festival-night/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><img src="/2022/09/10/astro-photography/2022-09-09-the-full-moon-at-mid-autumn-festival-night/the-full-moon.jpg" class=""><p>设备: Explore Scientific 152/1900 mm 马卡 + EXOS-2 Goto 赤道仪<br>相机: 索尼 Nex-5N<br>时间: 2022-09-09 晚<br>地点: 南阳台</p><blockquote><ol><li>这次尝试了索尼 Nex-5N 微单(无反)相机，APS-C 画幅导致无法一次拍下整个月面。所以将月面分为四部分分别拍摄，然后使用 PhotoShop 的 photomerge 进行自动拼接  </li><li>最终完成了整个满月的照片  </li><li>关于 D700 拍摄时模糊的问题，疑似是由于反光板升起导致机身震动引起的  </li><li>同时在调试设备时也发现相机的转接环和 T 桶可以进一步拧紧，这也可能是导致拍摄时成像模糊的一个可能的原因  </li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银河的浅影</title>
      <link href="/2022/08/29/astro-photography/2022-08-27-the-milky-way-at-a-glance/"/>
      <url>/2022/08/29/astro-photography/2022-08-27-the-milky-way-at-a-glance/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><img src="/2022/08/29/astro-photography/2022-08-27-the-milky-way-at-a-glance/cygnus-1.png" class="">  <p><br/></p><img src="/2022/08/29/astro-photography/2022-08-27-the-milky-way-at-a-glance/cygnus-2.png" class="">  <p><br/></p><img src="/2022/08/29/astro-photography/2022-08-27-the-milky-way-at-a-glance/cygnus-3.png" class="">  <p><br/></p><img src="/2022/08/29/astro-photography/2022-08-27-the-milky-way-at-a-glance/cygnus-4.png" class="">  <p><br/></p><img src="/2022/08/29/astro-photography/2022-08-27-the-milky-way-at-a-glance/stellarium-1.png" class="">  <p><br/></p><img src="/2022/08/29/astro-photography/2022-08-27-the-milky-way-at-a-glance/stellarium-2.png" class="">  <p>设备: EXOS-2 Goto 赤道仪<br>相机: Nikon D700 + 50mm/1.8D<br>时间: 2022-08-27 凌晨<br>地点: 市郊居民区小公园<br>总曝光时长: 约 30 分钟（8s * 100 + 10s * 100）<br>光污染等级: 6 ~ 7 级</p><blockquote><p>这是一次正式拍深空目标前的测试，主要测试在北京近郊、光污染约 6 级以上的位置进行深空目标拍摄的可行性<br>本次使用 50mm 焦距的常规镜头，由于周围居民楼和路灯光源较多，单次曝光30s以上，图像已经接近平场了<br>所以最终采用 8s/10s 的单张曝光时长，拍摄了 200 多张素材<br>配合拍摄的暗场和平场素材，使用 Sequator 进行叠加<br>经过后期，最终可以看到头顶上方天鹅座位置，淡淡的银河的影子，隐约可见红色的北美洲星云和一大片的星际物质<br>下一次带上主镜，正式开始深空摄影！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 React CRA 项目中使用 Alias 简化模块导入</title>
      <link href="/2022/07/26/react/use-path-alias-with-create-react-app/"/>
      <url>/2022/07/26/react/use-path-alias-with-create-react-app/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用 Create-React-App (CRA) 工具创建 React 项目后，我们常常会按照自己的风格，在 src 目录中组织目录结构。有时简单的项目，目录层级只有 1 级或者 2 级，那么在导入依赖组件时，可以写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Nav <span class="keyword">from</span> <span class="string">&quot;./_partial/Nav&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PostRepository <span class="keyword">from</span> <span class="string">&quot;../Repository/PostRepository&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样看起来似乎没什么问题。</p><p>但是当项目变得复杂后，要么，所有的文件都平铺在一个目录中；要么，就会出现多级嵌套的目录结构，导入模块就可能演变成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">&quot;../../../component/_partial/Footer&quot;</span>;</span><br></pre></td></tr></table></figure><p>导入模块变得越来越复杂，而问题似乎又不可避免。</p><p>那么有没有什么方式可以让我们简化导入语句，同时又不影响对依赖模块的查找呢？</p><p>这就是 alias 可以发挥作用的时候了。</p><p><br /></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>默认情况下，使用 Create-React-App 创建的项目是使用 webpack 进行打包的，在 webpack 的配置中，我们可以设置 <code>alias</code> 项，通过一个简单符号替换公共的路径前缀，比如 <code>~</code>。</p><p>我们需要在项目根目录的 <code>config/webpack.config.js</code> 中修改这个配置项，但是 config 目录默认是不存在的，需要先在项目的根目录下运行，将 webpack 所有的配置项生成到 config 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run eject</span><br></pre></td></tr></table></figure><p><em>如果项目存在未提交的内容，根据提示，需要先进行 commit，然后才能继续运行此命令.</em></p><blockquote><p>关于 <code>npm run eject</code> 命令，请查看<a href="https://create-react-app.dev/docs/available-scripts/#npm-run-eject">官方文档</a></p></blockquote><p>执行完成后，就可以在项目的根目录下看到 config 子目录了。</p><p>然后打开 <code>config/webpack.config.js</code> 文件，在变量声明区域追加一行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> basePath = path.resolve(__dirname, <span class="string">&quot;../src&quot;</span>);</span><br></pre></td></tr></table></figure><p><em>通常 path 模块已经被导入了，不过最好还是再进行一下确认</em></p><p>然后我们在向外暴露的函数中，找到最后 return 的巨大 object 里面的 <code>resolve.alias</code> 一项，向里面添加一组键值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">alias: &#123;</span><br><span class="line">    <span class="string">&quot;~&quot;</span>: basePath,  <span class="comment">// 添加这一行</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>修改后，就可以使用 <code>~</code> 作为前缀去导入内部组件了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">&quot;~/component/_partial/Footer&quot;</span>;</span><br></pre></td></tr></table></figure><p>上述的修改，会让 webpack 在打包时，使用 <code>basePath</code> 的值（我这里使用的是 src 目录的绝对路径）替换 <code>~</code> 符号，然后使用绝对路径去寻找依赖的组件。</p><p>这样就解决了导入路径繁琐的问题。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Create-React-App </tag>
            
            <tag> Import Path Alias </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 中的数据管理(译)</title>
      <link href="/2022/07/20/docker/manage-data-in-docker/"/>
      <url>/2022/07/20/docker/manage-data-in-docker/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><blockquote><p>原文: <a href="https://docs.docker.com/storage/">Manage data in Docker</a>  </p></blockquote><p>在 docker 容器中创建的所有文件，默认是存储在容器的 <a href="https://docs.docker.com/storage/storagedriver/images/container-layers.jpg">可写层 (writable layer) </a>中的。这就意味着：</p><ul><li>当容器不复存在的时候，数据没有持久化。并且，如果其他进程需要使用这些数据，从外部获取这些数据是非常困难的。</li><li>一个容器的可写层是和容器所在的宿主机紧密耦合在一起的，你很难将这些数据移动到其他位置。</li><li>向容器的可写层写入数据需要使用<a href="https://docs.docker.com/storage/storagedriver/">存储驱动 (storage driver) </a>来管理文件系统。这个存储驱动基于 Linux 内核，提供了一个复合的文件系统。这些额外的抽象，相比于使用 <em>数据卷 (data volume)</em> 直接向宿主机文件系统写入, 性能有所下降。</li></ul><p>当需要将容器中的文件存储到宿主机，以便在容器停止后将文件持久化时，docker 有两个选项可供使用：<em>volume</em> 和 <em>bind mount</em>.</p><p>Docker 也支持容器将文件存储到宿主机的内存中。而这些文件不会被持久化。如果你是在 Linux 上运行 Docker，可以使用 <em>tmpfs mount</em> 将文件存储在宿主机系统内存中。如果你是在 Windows 上运行 Docker，可以使用 <em>named pipe</em> 将文件存储在宿主机的系统内存里。</p><p>继续阅读来了解更多持久化数据和利用内存文件的内容。</p><p><br/></p><h2 id="选择正确的挂载类型"><a href="#选择正确的挂载类型" class="headerlink" title="选择正确的挂载类型"></a>选择正确的挂载类型</h2><p>无论你选择使用哪种挂载类型，数据从容器内看起来都是一样的。这些数据作为容器文件系统中的一个目录或者一个独立文件被暴露出来。</p><p>一个展示出 volume、bind mount 和 <code>tmpfs</code> mount 区别的简单办法，就是思考一下数据是放置在 Docker 宿主机上的什么位置。</p><p><img src="https://docs.docker.com/storage/images/types-of-mounts.png" alt=""></p><p><br/></p><ul><li><strong>Volume</strong> 储存在宿主机文件系统由 Docker 进行管理的部分中 (Linux 系统的目录为 <code>/var/lib/docker/volumes/</code>)。非 Docker 进程不应该修改文件系统的这部分。这是在 Docker 中持久化数据最好的方式。<br>&nbsp;</li><li><strong>Bind mount</strong> 有可能存储在宿主机系统的<em>任何地方</em>。它甚至有可能是重要的系统文件或者目录。宿主机上的非 Docker 进程或者 Docker 容器均可以在任意时刻对它进行修改。<br>&nbsp;</li><li><strong><code>tmpfs</code> mount</strong> 只会存储在宿主机的系统内存中，并且永远不会写入到宿主机的文件系统中。</li></ul><p><br/></p><h2 id="关于挂载类型的更多细节"><a href="#关于挂载类型的更多细节" class="headerlink" title="关于挂载类型的更多细节"></a>关于挂载类型的更多细节</h2><ul><li><p><strong><a href="https://docs.docker.com/storage/volumes/">Volume</a></strong>：由 Docker 创建和管理。你可以使用 <code>docker volume create</code> 命令显式地创建一个 volume，或者 Docker 可以在容器或服务创建的时候创建一个 volume。<br>&nbsp;<br>在创建一个 volume 的时候，它被存储在 Docker 宿主机的一个目录里。当你把这个 volume 挂载到容器时，实际被挂载到容器内的就是这个目录。这和 bind mount 的工作方式相似，除了 volume 是由 Docker 管理的，并且与宿主机的核心功能相隔离。<br>&nbsp;<br>一个给定的 volume 可以同时被挂载到多个容器内。如果没有正在运行的容器使用 volume 时，这个 volume 对 Docker 来说仍然是可用的，而且不会被自动移除。你可以使用 <code>docker volume prune</code> 移除不再使用的 volume。<br>&nbsp;<br>当你绑定一个 volume 时，它有可能是命名的 (named) 或者匿名的 (anonymous)。 匿名的 volume 在第一次被挂载到容器内时，没有被赋予一个显式的名称，所以 Docker 会给它指定一个在宿主机上保证唯一的随机名称。除了名称以外，命名 volume 和匿名 volume 的表现完全相同。<br>&nbsp;<br>volume 还支持使用 <em>卷驱动器 (volume drivers)</em>，卷驱动器允许你将数据存储在远程宿主机或云供应商，以及更多其他的可能。<br>&nbsp;</p></li><li><p><strong><a href="https://docs.docker.com/storage/bind-mounts/">Bind mount</a></strong>：自早期的 Docker 就可以使用。Bind mount 相比 volume 功能有限。当使用 bind mount 的时候，一个宿主机上的文件或者目录被挂载到容器中。这个文件或者目录通过它在宿主机的完整路径被引用。这个文件或者目录不需要预先存在于 Docker 宿主机上。当它不存在的时候，会按需被创建。Bind mount 性能非常好，但是它依赖于宿主机的文件系统拥有可用的特定目录结构。如果你正在开发新的 Docker 应用，应该考虑使用命名卷 (named volume)。bind mount 不可以直接使用 Docker CLI 命令进行管理。</p></li></ul><blockquote><p>⚠️ Bind mount 允许访问敏感文件<br>&nbsp;<br>使用 bind mount 的一个副作用，且不说是好是坏，它允许你通过<strong>容器</strong>内的进程改变<strong>宿主机</strong>文件系统，包括创建、修改，或者删除重要的系统文件或目录。这是一项可能存在安全问题的强大能力，包括会对宿主机上非 Docker 进程产生影响。</p></blockquote><p>&nbsp;</p><ul><li><strong><a href="https://docs.docker.com/storage/tmpfs/">tmpfs mount</a></strong>：<code>tmpfs</code> mount 不会持久化到磁盘，不论是在 Docker 宿主机上还是容器里。容器可以在生命周期内，使用这种方式存储非持久化的状态或敏感信息。举个例子，在 Docker 内部，swarm 服务使用 <code>tmpfs</code> mount 将<a href="https://docs.docker.com/engine/swarm/secrets/">私密数据 (secrets) </a>挂载到服务的容器内部。<br>&nbsp;</li><li><strong><a href="https://docs.microsoft.com/en-us/windows/desktop/ipc/named-pipes">named pipe</a></strong>：<code>npipe</code> mount 可以用于 Docker 宿主机和容器之间的交流。常见的使用场景是，在容器中运行一个第三方工具，并且使用 named pipe 将它连接到 Docker Engine API。</li></ul><p>Bind mount 和 volume 都可以使用 <code>-v</code> 或 <code>--volume</code> 被挂载到容器内，但是两者的语法有一些细微的差别。对于 <code>tmpfs</code> mount，你可以使用 <code>--tmpfs</code>。我们推荐对容器和服务使用 <code>--mount</code>，来进行 bind mount、volume 或者 <code>tmpfs</code> mount 挂载，因为它的语法更加清晰。</p><p><br/></p><h2 id="Volume-的适用场景"><a href="#Volume-的适用场景" class="headerlink" title="Volume 的适用场景"></a>Volume 的适用场景</h2><p>在 Docker 容器中或服务中进行数据持久化时，Volume 是比较推荐的方式。关于 volume 的一些使用示例如下：</p><ul><li>在多个运行的容器之间共享数据。如果你没有显式地创建 volume，它则会在第一次挂载进容器的时候被创建。当这个容器停止运行或被移除的时候，这个 volume 仍然存在。多个容器可以同时挂载同一个 volume，不论是读写的还是只读。Volumes 只有你显式移除它的时候才会被删除。<br>&nbsp;</li><li>Docker 宿主机不能保证存在给定的目录或者文件结构。Volume 会帮你把 Docker 宿主机的设置与容器 runtime 进行解耦。<br>&nbsp;</li><li>你希望将容器的数据储存到远程宿主机或者云提供商，而不是本地。<br>&nbsp;</li><li>你需要从一个 Docker 宿主机备份、恢复或者迁移数据到另一台机器时，volume 是更好的选择。你可以关停使用 volume 的容器，然后备份 volume 的目录 (比如 <code>/var/lib/docker/volumes/&lt;volume-name&gt;</code>)。<br>&nbsp;</li><li>当使用 Docker Desktop 运行的应用需要高性能的 I/O 时。 Volume 是存储在 Linux 虚拟机中，而不是宿主机，这意味着读和写都有着更低的延迟和更高的吞吐量。<br>&nbsp;</li><li>当使用 Docker Desktop 运行的应用需要完全的原生文件系统。举个例子，数据库的引擎需要精确控制磁盘 flush，以此来保证事务持久性。Volume 被存储在 Linux 虚拟机中，因此可以做出如此保证。然而 macOS 和 Windows 的文件系统行为稍微有些不同，因此 bind mount 对这两个系统并不友好。<sup>[1]</sup></li></ul><p><br/></p><h2 id="bind-mount-的适用场景"><a href="#bind-mount-的适用场景" class="headerlink" title="bind mount 的适用场景"></a>bind mount 的适用场景</h2><p>一般来说，你应该尽可能使用 volume。Bind mount 适用于如下几种类型的场景：</p><ul><li>向容器共享宿主机上的配置文件。这也是 Docker 为容器提供 DNS 解析的默认方式。Docker 会挂载宿主机的 <code>/etc/resolv.conf</code> 文件到每个容器中，来向容器提供 DNS 解析。<br>&nbsp;</li><li>在开发环境的 Docker 宿主机和容器之间共享源码或构建构件 (build artifacts)。比如，你可能会将 Maven 的 <code>target/</code> 目录挂载到容器内，并且每次在 Docker 宿主机上构建 Maven 项目时，容器都能获得重建构件的访问权。<br>&nbsp;<br>如果使用这种方式将 Docker 用于开发，你需要在用于生产的 Dockerfile 中，将可用于生产的构件 (artifact) 直接拷贝到容器内，而不是依赖于 bind mount。<br>&nbsp;</li><li>Docker 宿主机上，容器 bind mount 所需的文件或者目录结构可以保证始终不变。</li></ul><p><br/></p><h2 id="tmpfs-mount-的适用场景"><a href="#tmpfs-mount-的适用场景" class="headerlink" title="tmpfs mount 的适用场景"></a>tmpfs mount 的适用场景</h2><p><code>tmpfs</code> mount 最适合用于既不希望将数据持久化到宿主机，也不希望持久化到容器内的场景。或许是出于安全原因或保护容器的性能，你的应用需要将非持久化的状态数据写入一个较大的 volume 时，适合使用 tmpfs mount。</p><p><br/></p><h2 id="使用-bind-mount-和-volume-的小提示"><a href="#使用-bind-mount-和-volume-的小提示" class="headerlink" title="使用 bind mount 和 volume 的小提示"></a>使用 bind mount 和 volume 的小提示</h2><p>不论你使用 bind mount 或是 volume，请记住以下几点：</p><ul><li>如果你将一个 <strong>空卷 (empty volume)</strong> 挂载到容器的一个目录中，而这个目录中已经存在文件或者目录了，那么这些已存在的文件或目录会被复制到 volume 中。与之相似的，如果你启动一个容器，并且指定了一个尚不存在的 volume，那么就会新创建出一个空的 volume。要为其他容器预填充所需的数据，这是一种不错的办法。<br>&nbsp;</li><li>如果你挂载一个 <strong>bind mount 或 非空 volume</strong> 到容器中的一个目录，这个目录中已经存在了文件或者子目录，这些文件或者目录会被这次挂载遮蔽掉。就像你把文件保存在 Linux 的 <code>/mnt</code> 目录，然后又挂载了一个 U 盘到 <code>/mnt</code>。那么 <code>/mnt</code> 中的内容就会被 U 盘遮蔽掉，直到 U 盘被移除。被遮蔽的文件不会被删除或者修改，但是在 bind mount 或者 volume 被挂载期间会无法访问。</li></ul><p><br/></p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><ul><li>学习更多关于 <a href="https://docs.docker.com/storage/volumes/">volumes</a> 的内容。</li><li>学习更多关于 <a href="https://docs.docker.com/storage/bind-mounts/">bind mounts</a> 的内容。</li><li>学习更多关于 <a href="https://docs.docker.com/storage/tmpfs/">tmpfs mounts</a> 的内容。</li><li>学习更多关于 <a href="https://docs.docker.com/storage/storagedriver/">storage drivers</a> 的内容，虽然 storage drivers 和 bind mount 以及 volume 并不相关，但是它允许你向容器的可写层 (writable layer) 存储数据。</li></ul><p><br/></p><h2 id="附注"><a href="#附注" class="headerlink" title="*附注"></a><sup>*</sup>附注</h2><p>[1] 不确定的中文表达，原文如下：</p><blockquote><p>Volumes are stored in the Linux VM and can make these guarantees, whereas bind mounts are remoted to macOS or Windows, where the file systems behave slightly differently.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Mac OS 上创建 Android 虚拟设备</title>
      <link href="/2022/07/13/spider/create-an-android-virtual-device-on-macos/"/>
      <url>/2022/07/13/spider/create-an-android-virtual-device-on-macos/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们手边没有实体的调试设备时, 可能会使用第三方厂商的 Android 模拟器, 或者基于 VirtualBox 的 Genymotion 创建虚拟设备.<br>机缘巧合, 我发现了一种新的创建 Android 虚拟设备的方式, 可以通过命令行独立使用 Android Studio 的 Emulator 模拟器.</p><p>使用这种方式创建出来的虚拟设备, 兼容性要比 x86 的 Genymotion 要好, 不需要 Arm Translator 一类的东西, 性能也还不错, 虽然有些诡异的应用还是不能正常运行, 但是也能临时应付一下没有实体设备的场景.</p><p>下面就具体介绍一下安装方式.</p><p><br/></p><h2 id="安装-SDK"><a href="#安装-SDK" class="headerlink" title="安装 SDK"></a>安装 SDK</h2><p>使用 home-brew 安装 jdk 和 android-sdk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install openjdk@8</span><br><span class="line">$ brew install android-sdk</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>将项目启动依赖的环境变量设置一下, 然后还需要将 emulator 所在的目录添加到环境变量 PATH 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ANDROID_SDK_ROOT=/usr/<span class="built_in">local</span>/share/android-sdk/</span><br><span class="line">$ <span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/Cellar/openjdk@8/1.8.0+322/</span><br><span class="line">$ <span class="built_in">export</span> ANDROID_AVD_HOME=<span class="variable">$HOME</span>/.android/avd</span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$ANDROID_SDK_ROOT</span>/emulator:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><em>这里 openjdk@8 子目录的名称需要手动确认, 版本号可能随着时间的推移发生变更</em></p><p><br/></p><h2 id="安装-Android-SDK-组件"><a href="#安装-Android-SDK-组件" class="headerlink" title="安装 Android SDK 组件"></a>安装 Android SDK 组件</h2><p>在下载安装 Android 系统之前, 还需要安装必要的组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sdkmanager <span class="string">&quot;platform-tools&quot;</span></span><br></pre></td></tr></table></figure><p>我们可以再查看一下可选用的系统版本列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sdkmanager --list | grep system-images</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="选择并安装-Android-系统"><a href="#选择并安装-Android-系统" class="headerlink" title="选择并安装 Android 系统"></a>选择并安装 Android 系统</h2><p>选择好系统之后, 我们可以选择安装指定版本的 Android API 和系统镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sdkmanager <span class="string">&quot;platforms;android-30&quot;</span></span><br><span class="line">$ sdkmanager --install <span class="string">&quot;system-images;android-30;google_apis;x86_64&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><h2 id="创建虚拟设备"><a href="#创建虚拟设备" class="headerlink" title="创建虚拟设备"></a>创建虚拟设备</h2><p>完成上述所有准备工作后, 就可以开始创建一台 Android 虚拟设备了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;no&quot;</span> | avdmanager --verbose create avd --force --name <span class="string">&quot;android11&quot;</span> --package <span class="string">&quot;system-images;android-30;google_apis;x86_64&quot;</span> --tag <span class="string">&quot;google_apis&quot;</span> --abi <span class="string">&quot;x86_64&quot;</span></span><br></pre></td></tr></table></figure><p><br/></p><h2 id="提前配置启动参数"><a href="#提前配置启动参数" class="headerlink" title="提前配置启动参数"></a>提前配置启动参数</h2><p>如果直接启动的话, 还需要通过命令行添加一些参数.<br>为了方便, 可以将这些常用参数直接写入配置文件中, 避免每次设置.</p><p>将如下几行配置追加到 <code>$ANDROID_AVD_HOME/android11.avd/config.ini</code> 文件中</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">skin.name=1080x1920</span><br><span class="line">hw.lcd.density=480</span><br><span class="line">hw.keyboard=yes</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="启动虚拟设备"><a href="#启动虚拟设备" class="headerlink" title="启动虚拟设备"></a>启动虚拟设备</h2><p>接下来就可以根据配置的设备名称, 启动虚拟设备了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$ANDROID_SDK_ROOT</span>/emulator</span><br><span class="line">$ emulator -avd android11</span><br></pre></td></tr></table></figure><p><em>这里有个遗留问题是, 虽然我们已经将 emulator 的目录添加到了环境变量中, 但是在任意位置启动时会抛出异常, 解决办法是先 cd 进 emulator 的目录, 然后再启动, 不知道这个问题以后会不会修复</em></p><p>这样, 我们就成功的在 Mac OS 上创建了一台可以用于调试的 Android 虚拟设备.<br>之后就可以使用 ADB 或者直接拖动 apk 文件到虚拟设备安装应用了.</p><p><br/></p><h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><ol><li>由于不同的镜像或 Android API 版本最终能获得的权限不同, 如果需要 root 权限还需要自行测试, 本文使用的示例是经过测试可以获取 root 权限的.</li><li>特定的 Android 9 和任意版本的 Android 11 镜像已经默认支持 ARM 指令集的应用.</li><li>更多详细内容可以参考 Android Studio <a href="https://developer.android.com/studio/run/emulator">Emulator</a>相关的文档.</li><li>会有一些诡异的应用无法安装或者无法启动, 需要尝试才能知道.</li></ol><p><br/></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://gist.github.com/mrk-han/66ac1a724456cadf1c93f4218c6060ae">Install and Create Emulators using AVDMANAGER and SDKMANAGER</a><br>[2] <a href="https://developer.android.com/studio/command-line">Android Studio - Command line tools</a><br>[3] <a href="https://developer.android.com/studio/run/emulator-commandline">Android Studio - Start the emulator from the command line</a><br>[4] <a href="https://developer.android.com/studio/releases/emulator#support_for_arm_binaries_on_android_9_and_11_system_images">Support for ARM binaries on Android 9 and 11 system images</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>土星</title>
      <link href="/2022/07/12/astro-photography/2022-07-11-saturn/"/>
      <url>/2022/07/12/astro-photography/2022-07-11-saturn/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><p><img src="20220711-saturn.png" alt=""></p><p>设备: Explore Scientific 152/1900 mm 马卡 + EXOS-2 Goto 赤道仪<br>相机: ZWO ASI385MC<br>时间: 2022-07-11 凌晨<br>地点: 南阳台</p><blockquote><p>由于南阳台观测空间有限, 手动控制电跟拍摄素材<br>将天顶镜拆下来换成两个延焦筒, 固定行星相机时还要稍微外撤一点才能刚好对焦<br>步骤:</p><ol><li>使用 PIPP 对行星进行稳定居中, 转换为 tif 格式保存</li><li>将全部 tif 格式帧使用 AS!3 打开, 配置行星堆叠参数, 启用锐化</li><li>最终得到本次的成果</li><li>原本录制了 20 段视频, 每段视频 120s, 最终只用了一段视频就达到了不错的效果也是很让人意外</li><li>过几个月要补拍上次不那么成功的木星</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柏拉图环形山与阿尔卑斯谷</title>
      <link href="/2022/07/11/astro-photography/plato-and-vallis-alpes/"/>
      <url>/2022/07/11/astro-photography/plato-and-vallis-alpes/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><p><img src="2022-07-10-plato-and-vallis-alpes.jpeg" alt=""></p><p>设备: Explore Scientific 152/1900 mm 马卡 + EXOS-2 Goto 赤道仪<br>相机: ZWO ASI385MC<br>时间: 2022-07-10 晚<br>地点: 南阳台</p><p><br/></p><p>主要地标包括:</p><ol><li>柏拉图环形山</li><li>阿尔卑斯山脉</li><li>阿尔卑斯谷</li><li>卡西尼环形山</li><li>雨海(左下)</li><li>冷海(右上)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渐盈凸月(初十)</title>
      <link href="/2022/07/10/astro-photography/2022-07-08-waxing-gibbous-moon/"/>
      <url>/2022/07/10/astro-photography/2022-07-08-waxing-gibbous-moon/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><p><img src="20220708-waxing-gibbous-moon.jpeg" alt=""></p><p>设备: Explore Scientific 152/1900 mm 马卡 + EXOS-2 Goto 赤道仪<br>相机: 尼康 D700<br>时间: 2022-07-08 晚<br>地点: 小区南侧内部道路(无路灯)</p><blockquote><p>1.第一次尝试了漂移法对极轴, 在指南针的辅助下小幅提升了对极轴的精度<br>2.同时尝试了一星校准, 看起来没有什么用处, 校准后寻找目标差了非常远<br>3.尝试使用了极轴镜, 不过由于光污染较严重, 看不到北极星, 所以只是体验了一下极轴镜的用法<br>4.将单反转接环的延焦筒更换为了望远镜调焦座的延焦筒, 增强了稳定性<br>5.后期处理过的图片仍然较模糊, 拍摄时实时取景和按下快门拍摄后的清晰度也不一致, 需要进一步调整</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 React 项目中使用 Protobuf 协议</title>
      <link href="/2022/06/14/react/using-protobuf-in-react-application/"/>
      <url>/2022/06/14/react/using-protobuf-in-react-application/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文总结了在 React App 中处理 ProtoBuf 协议的一种方式, 同时包含 React 自定义 Hook, axios interceptors 等内容, 共同组成了前后端交互的相关功能.</p><p>跟随本文的步骤, 可以完整的创建一个独立的示例 App.</p><p>本文主要按照以下几个步骤进行:</p><ol><li>创建 React App</li><li>安装依赖</li><li>创建自定义 Hook</li><li>创建并配置 axios 实例</li><li>编写 Proto 定义</li><li>创建自定义组件组件</li><li>为 axios 实例添加 interceptors 函数</li><li>将组件添加到 App</li><li>修改 index.js</li><li>启动项目</li></ol><p>本文假设你已经有了可以正常运行的 Node.js 环境. 如果还没有, 你可以从 <a href="https://nodejs.org/zh-cn/download/">官网</a> 进行下载安装.</p><p><br/></p><h2 id="创建-React-App"><a href="#创建-React-App" class="headerlink" title="创建 React App"></a>创建 React App</h2><p>使用 npm 创建一个名为 proto-test 的项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-react-app proto-test</span><br></pre></td></tr></table></figure><p><em>按照<a href="https://github.com/facebook/create-react-app">文档</a>的推荐, 无需预先安装 create-react-app 工具, 并且建议先卸载全局安装的 create-react-app</em></p><p><em>创建项目并安装依赖的过程可能会持续几分钟, 请耐心等待</em></p><p><br/></p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>首先进入 proto-test 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> proto-test</span><br></pre></td></tr></table></figure><p>由于 React 18 版本相关依赖存在一些原因未知的问题, 这里使用 React 17 版本.<br>通过修改 package.json 文件指定依赖版本, 将 package.json 文件中的 <code>dependencies</code> 值改为如下内容:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;protobufjs&quot;: &quot;^6.11.3&quot;,</span><br><span class="line">  &quot;axios&quot;: &quot;^0.25.0&quot;,</span><br><span class="line">  &quot;react&quot;: &quot;^17.0.2&quot;,</span><br><span class="line">  &quot;react-dom&quot;: &quot;^17.0.2&quot;,</span><br><span class="line">  &quot;react-scripts&quot;: &quot;5.0.0&quot;,</span><br><span class="line">  &quot;web-vitals&quot;: &quot;^2.1.4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存 package.json 文件后, 使用如下命令安装全部依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i</span><br></pre></td></tr></table></figure><p>注意: Protobufjs 文档中给出的相关示例, 并不完全适用于 react app, 原文档仅供参考.</p><p><em><a href="https://axios-http.com/">Axios 文档</a></em><br><em><a href="https://github.com/protobufjs/protobuf.js">Protobufjs 文档</a></em>  </p><p><br/></p><h2 id="创建自定义-Hook"><a href="#创建自定义-Hook" class="headerlink" title="创建自定义 Hook"></a>创建自定义 Hook</h2><p>首先, 我们在项目的 src 目录下创建一个名为 hooks 子目录, 并在其中创建一个名为 useAxios.js 的文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> src</span><br><span class="line">$ mkdir hooks</span><br><span class="line">$ touch hooks/useAxios.js</span><br></pre></td></tr></table></figure><p>使用文本编辑器打开 useAxios.js 文件, 向其中粘贴如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useAxios = <span class="function">(<span class="params">configObj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        axiosInstance,</span><br><span class="line">        method,</span><br><span class="line">        url,</span><br><span class="line">        requestConfig = &#123;&#125;,</span><br><span class="line">    &#125; = configObj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [response, setResponse] = useState([]);</span><br><span class="line">    <span class="keyword">const</span> [error, setError] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> res = <span class="keyword">await</span> axiosInstance[method.toLowerCase()](url, &#123;</span><br><span class="line">                    ...requestConfig,</span><br><span class="line">                    signal: controller.signal</span><br><span class="line">                &#125;);</span><br><span class="line">                setResponse(res.data);</span><br><span class="line">            &#125; <span class="function"><span class="title">catch</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err.message);</span><br><span class="line">                setError(err.message);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                setLoading(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        fetchData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> controller.abort();</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [response, error, loading];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useAxios;</span><br></pre></td></tr></table></figure><p>这段代码主要实现的功能如下:</p><ul><li>使用箭头函数语法声明一个函数, 并赋值给 <code>useAxios</code> 变量;</li><li>对参数 <code>configObj</code> 进行解构赋值(Destructuring Assignment), 获得 <code>axiosInstance</code>, <code>method</code>, <code>url</code>, <code>requestConfig</code> 四个变量, 并为 <code>requestConfig</code> 设置默认值.</li><li>分别使用 <code>useState</code> Hook 设置了三个局部状态变量 <code>response</code>, <code>error</code>, <code>loading</code>.</li><li>在 <code>useEffect</code> Hook 中使用 axios 执行请求, 并更新局部状态变量. 返回一个使用 <code>controller</code> 清除状态的函数.</li><li>返回 <code>response</code>, <code>error</code>, <code>loading</code> 三个变量.</li><li>使用 <code>export default</code> 对外暴露刚刚声明的 <code>useAxios</code> 变量.</li></ul><p><br/></p><h2 id="创建并配置-axios-实例"><a href="#创建并配置-axios-实例" class="headerlink" title="创建并配置 axios 实例"></a>创建并配置 axios 实例</h2><p>在 src 目录下创建一个名为 apis 的子目录, 并在其中创建一个名为 base.js 的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir apis</span><br><span class="line">$ touch apis/base.js</span><br></pre></td></tr></table></figure><p>向 base.js 中粘贴如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> protobuf <span class="keyword">from</span> <span class="string">&#x27;protobufjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = <span class="string">&#x27;http://192.168.0.106:8080/api/v1/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: BASE_URL,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/x-protobuf&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    responseType: <span class="string">&#x27;arraybuffer&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance;</span><br></pre></td></tr></table></figure><p>在这段代码中, 实现的功能如下:</p><ul><li>设置了全局常量 <code>BASE_URL</code>, 这是你将要请求的接口 url 的通用前缀.</li><li>创建了一个 axios 实例并赋值给 <code>instance</code> 变量, 并在传入的 config 参数对象中设置请求头的 <code>Accept</code> 字段和响应实体将要使用的数据类型 <code>arraybuffer</code>.</li><li>使用 <code>export default</code> 对外暴露刚刚创建的 axios 实例 <code>instance</code>.</li></ul><p><br/></p><h2 id="编写-Proto-定义"><a href="#编写-Proto-定义" class="headerlink" title="编写 Proto 定义"></a>编写 Proto 定义</h2><p>在 src 目录中创建一个名为 protos 的子目录, 并在其中创建一个名为 ExampleResponse.proto 的文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir protos</span><br><span class="line">$ touch protos/ExampleResponse.proto</span><br></pre></td></tr></table></figure><p>在 ExampleResponse.proto 文件中, 粘贴如下代码:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message ExampleResponse &#123;</span><br><span class="line">    enum Status &#123;</span><br><span class="line">        OK = 0;</span><br><span class="line">        ERR = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    optional Status status = 1;</span><br><span class="line">    string msg = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你定义了:</p><ul><li>一个 <code>ExampleResponse</code> 类型的 message, 其中包含一个自定义枚举类型的 <code>status</code> 字段和一个 string 类型的 <code>msg</code> 字段.</li><li>将 message 名称与文件名设计为同名, 以便后续可以更方便的加载.</li></ul><p><em>你还需要实现一个使用这个消息定义的接口服务, 使用相同的 proto 定义对数据进行编码</em></p><p><br/></p><h2 id="创建自定义组件"><a href="#创建自定义组件" class="headerlink" title="创建自定义组件"></a>创建自定义组件</h2><p>在 src 目录中, 创建名为 components 的子目录, 并在其中创建一个名为 ExampleComponent.js 的文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir components</span><br><span class="line">$ touch components/ExampleComponent.js</span><br></pre></td></tr></table></figure><p>打开 ExampleComponent.js 文件, 向其中粘贴如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useAxios <span class="keyword">from</span> <span class="string">&#x27;../hooks/useAxios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;../apis/base&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ExampleResponse <span class="keyword">from</span> <span class="string">&#x27;../protos/ExampleResponse.proto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [msg, error, loading] = useAxios(&#123;</span><br><span class="line">        axiosInstance: axios,</span><br><span class="line">        method: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;/hello/protobuf&quot;</span>,</span><br><span class="line">        requestConfig: &#123;</span><br><span class="line">            pb: &#123;</span><br><span class="line">                response: ExampleResponse,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">            &#123;loading &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">            &#123;!loading &amp;&amp; error &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;error&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">            &#123;!loading &amp;&amp; !error &amp;&amp; msg &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;JSON.stringify(msg)&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExampleComponent;</span><br></pre></td></tr></table></figure><p>在这段代码中, 实现的功能如下:</p><ul><li>导入了前几步声明的 <code>useAxios</code> Hook, axios 实例, 以及 ExampleResponse.proto 文件.</li><li>在 App 组件中使用 <code>useAxios</code> Hook 发送请求, 在参数对象中指定要求的参数值. 在 <code>requestConfig</code> 中添加一个自定义字段 <code>pb</code>, 里面指定响应所使用的 proto 文件. url 的值和之前声明的 BASE_URL 拼接到一起组成了完整的 api 地址.</li><li>返回组件, 根据 <code>response</code>, <code>error</code> 和 <code>loading</code> 的值决定页面中展示的数据.</li></ul><p><br/></p><h2 id="为-axios-实例添加-interceptors-函数"><a href="#为-axios-实例添加-interceptors-函数" class="headerlink" title="为 axios 实例添加 interceptors 函数"></a>为 axios 实例添加 interceptors 函数</h2><p>在 apis/base.js 文件中, <code>export default instance</code> 语句的上方, 粘贴如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除 object 中指定的 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">const</span> omit = <span class="function">(<span class="params">obj, uselessKeys</span>) =&gt;</span> </span><br><span class="line"> <span class="built_in">Object</span>.keys(obj).reduce(<span class="function">(<span class="params">acc, key</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> uselessKeys.includes(key) ?</span><br><span class="line">     acc :</span><br><span class="line">     &#123;...acc, <span class="attr">key</span>: obj[key]&#125;</span><br><span class="line"> &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据 proto 文件导入后的路径获取 message 类型名称</span></span><br><span class="line"><span class="comment">* 要求文件名与主要 message 同名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> getProtoName = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> start = path.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">const</span> end = path.indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> path.substring(start, end);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对 protobuf 协议的 response.data 进行解码, 转换成对象返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">instance.interceptors.response.use(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; config &#125; = response;</span><br><span class="line">    <span class="keyword">const</span> &#123; pb &#125; = config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pb.response &amp;&amp; response.data) &#123;</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">await</span> protobuf.load(pb.response)</span><br><span class="line">        <span class="keyword">const</span> msgType = root.lookupType(getProtoName(pb.response));</span><br><span class="line">        <span class="keyword">const</span> msg = msgType.decode(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(response.data));</span><br><span class="line">        <span class="keyword">const</span> newData = msgType.toObject(msg);</span><br><span class="line">        <span class="keyword">const</span> newRes = omit(response, [<span class="string">&quot;data&quot;</span>]);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...newRes,</span><br><span class="line">            data: newData,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这段代码中, 实现的功能如下:</p><ul><li>声明了一个 <code>omit</code> 函数, 用来移除对象中指定的键值对.</li><li>声明了一个 <code>getProtoName</code> 函数, 用于从导入的 proto 文件中获取文件名, 用于加载 message 类型. </li><li>使用 <code>instance.interceptors.response.use</code> 为 axios 实例添加一个拦截器, 用于在 <code>response</code> 返回给请求者之前对其进行处理. 这里使用了 async 函数, 主要是为了处理 <code>protobuf.load</code> 相关的逻辑. 这里与文档中的用法稍有区别.</li><li>在拦截器函数内部, 使用对象解构的方式获得 <code>response.config</code> 和 <code>response.config.pb</code> 对象, 分别赋值给 <code>config</code> 和 <code>pb</code> 变量. <code>pb</code> 对象是在组件中发起请求时, 添加到 requestConfig 中的自定义对象, 其中包含响应数据所对应的 proto 文件. </li><li>使用 protobufjs 对响应数据进行处理, 在返回前对数据进行解码.</li></ul><p>有两点需要注意:</p><ul><li><p>在 protobufjs 的文档中, 示例代码使用 <code>protobuf.load</code> 加载 proto 文件时直接使用字符串类型的文件名作为参数, 但是在 react 的项目中, 实际的文件路径和文件系统中的路径并不一致, 所以直接使用文件系统中的文件路径做参数会导致异常. 这里先在组件中把 proto 文件导入为模块, 再使用模块路径进行加载可以正常运行.</p></li><li><p>在使用 <code>msgType.decode</code> 对响应实体数据进行解码时, 要求参数使用 <code>Uint8Array</code> 类型, 首先需要进行一次类型转换. 其次, 使用 <code>Uint8Array.from</code> 进行转换时, 无返回值, 会导致后续没有数据. 这里需要使用 <code>new Uint8Array</code> 的方式进行类型转换.</p></li></ul><p><br/></p><h2 id="将组件添加到-App"><a href="#将组件添加到-App" class="headerlink" title="将组件添加到 App"></a>将组件添加到 App</h2><p>将 src/app.js 中的代码替换为如下内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ExampleComponent <span class="keyword">from</span> <span class="string">&#x27;./components/ExampleComponent&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;main className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">            &lt;h1&gt;useAxios Hooks&lt;/h1&gt;</span><br><span class="line">            &lt;ExampleComponent /&gt;</span><br><span class="line">        &lt;/main&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>在这段代码中, 实现的功能如下:</p><ul><li>声明了 App 组件, 这个组件将作为整个应用的基础</li><li>导入刚刚创建的 <code>ExampleComponent</code> 组件, 并将其添加到 App 中.</li></ul><p><br/></p><h2 id="修改-index-js"><a href="#修改-index-js" class="headerlink" title="修改 index.js"></a>修改 index.js</h2><p>打开 src/index.js, 使用如下代码替换文件中已有的内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;React.StrictMode&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/React.StrictMode&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这段代码, 实现了如下功能:</p><ul><li>渲染 App 组件</li></ul><p><br/></p><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p>打开命令行, 进入到项目的根目录, 使用如下命令启动项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure><p>项目启动完成后, 就可以看到后端返回的 Protobuf 协议数据, 解码后展示在了页面中.</p><p><br/></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/lihanx/proto-test">[Github]示例代码</a></p><p><em>示例代码中使用的 api 需要替换为你自己实现的后端 api</em></p><p><br/></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://www.youtube.com/watch?v=NqdqnfzOQFE">[YouTube]Use Axios with React Hooks for Async-Await Requests</a><br>[2] <a href="https://github.com/protobufjs/protobuf.js/issues/1023">[Issue]illegal token ‘&lt;’ (/demo.proto, line 1)</a><br>[3] <a href="https://github.com/protobufjs/protobuf.js/issues/806">[Issue]Uncaught Error: illegal buffer</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Protobuf </tag>
            
            <tag> Axios </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Golang 访问关系型数据库(译)</title>
      <link href="/2022/06/09/golang/database-access/"/>
      <url>/2022/06/09/golang/database-access/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><blockquote><p>原文: <a href="https://go.dev/doc/tutorial/database-access">https://go.dev/doc/tutorial/database-access</a></p></blockquote><p>本教程介绍了使用 Go 和 Go 标准库中的 <code>database/sql</code> 访问关系型数据库的基础知识.</p><p>如果你对 Go 和它的工具有基本的了解, 那么本篇教程将可以发挥它的最大功效. 如果你是第一次接触 Go, 请阅读 <a href="https://go.dev/doc/tutorial/getting-started">Tutorial: Get started with Go</a>, 快速地了解一下 Go.</p><p>你即将使用的 <code>database/sql</code> 包中, 包含了一些数据类型和函数, 可以用于连接数据库、执行会话、取消正在执行的操作, 等等. 关于使用这个包的更多细节, 请见<a href="https://go.dev/doc/database/index">Accessing databases</a>.</p><p>在本篇教程中, 你将要创建一个数据库, 然后编写代码来对这个数据库进行访问. 你将要完成的示例项目, 是一个关于复古爵士乐的曲库.</p><p>在本篇教程中, 你将会按照以下几个小节, 循序渐进地进行学习:</p><ol><li>为你的代码创建目录</li><li>设置一个数据库</li><li>导入数据库驱动</li><li>获取一个数据库句柄并进行连接</li><li>查询多行记录</li><li>查询单行记录</li><li>添加数据</li></ol><p><strong>Note:</strong> 更多其他教程, 请见 <a href="https://go.dev/doc/tutorial/index.html">Tutorials</a></p><p><br/></p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li><strong>已安装 <a href="https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/">MySQL</a> 关系型数据库管理系统(DBMS).</strong></li><li><strong>已安装 Go.</strong> 安装说明, 请见<a href="https://go.dev/doc/install">Installing Go</a>.</li><li><strong>代码编辑器.</strong> 任何你已有的文本编辑器都可以满足需求.</li><li><strong>命令行终端.</strong> Go 可以在 Linux 或 Mac 终端正常工作, 也可以在 Windows 的 PowerShell 或 cmd 中运行.</li></ul><p><br/></p><h2 id="为你的代码创建目录"><a href="#为你的代码创建目录" class="headerlink" title="为你的代码创建目录"></a>为你的代码创建目录</h2><p>为了开始编写代码, 你需要先创建一个目录.</p><p>1.打开命令行, 进入到 Home 目录</p><p>在 Linux 或者 Mac 上执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span></span><br></pre></td></tr></table></figure><p>或在 Windows 上执行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; <span class="built_in">cd</span> %HOMEPATH%</span><br></pre></td></tr></table></figure><p>下文将仅使用 <code>$</code> 表示命令提示符. 所有命令在 Windows 系统也都同样可以运行.</p><p>2.在命令行提示符后面输入命令, 为你的代码创建一个名为 data-access 的目录.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir data-access</span><br><span class="line">$ <span class="built_in">cd</span> data-access</span><br></pre></td></tr></table></figure><p>3.创建一个模块, 用来管理你在学习本教程的过程中, 将要添加到项目中的依赖.</p><p>运行 <code>go mod init</code> 命令, 并使用一个你的新代码要用的模块路径(module path)作为参数.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init example/data-access</span><br><span class="line">go: createing new go.mod: module example/data-access</span><br></pre></td></tr></table></figure><p>这个命令创建了一个 go.mod 文件用于追踪依赖, 你添加的所有依赖都将会列在这个文件中. 更多内容, 请务必阅读<a href="https://go.dev/doc/modules/managing-dependencies">Managing dependencies</a></p><p><strong>Note:</strong> 在实际的开发中, 最好根据你的需求制定一个更具体的模块路径(module path). 更多详情, 请见<a href="https://go.dev/doc/modules/managing-dependencies#naming_module">Managing dependencies</a></p><p><br/></p><h2 id="设置一个数据库"><a href="#设置一个数据库" class="headerlink" title="设置一个数据库"></a>设置一个数据库</h2><p>在这一步, 你将会创建一个需要用到的数据库. 你将使用 DBMS 的 CLI 直接创建数据库和数据表, 并使用 CLI 添加数据.</p><p>你将会创建一个保存黑胶唱片上关于复古爵士乐数据的数据库.</p><p>这里的代码使用 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql.html">MySQL CLI</a>, 但是大多数 DBMS 都有它们自己的 CLI, 并且拥有相似的功能.</p><p>1.打开一个新的命令提示符<br>2.在命令行中, 登录你的 DBMS, MySQL 的示例如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u -p</span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>3.在 mysql 的命令提示符中, 创建一个数据库:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create datebase recordings;</span><br></pre></td></tr></table></figure><p>4.切换到刚刚添加的数据库中, 以便新增数据表.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use recordings;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><p>5.打开文本编辑器, 在 data-access 文件夹中, 创建一个名为 create-tables.sql 的文件, 用于保存创建数据表的 SQL 语句.</p><p>6.打开这个文件, 粘贴如下 SQL 代码并保存:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> album;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> album (</span><br><span class="line">  <span class="keyword">id</span>         <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  title      <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  artist     <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  price      <span class="built_in">DECIMAL</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> album</span><br><span class="line">  (title, artist, price)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;Blue Train&#x27;</span>, <span class="string">&#x27;John Coltrane&#x27;</span>, <span class="number">56.99</span>),</span><br><span class="line">  (<span class="string">&#x27;Giant Steps&#x27;</span>, <span class="string">&#x27;John Coltrane&#x27;</span>, <span class="number">63.99</span>),</span><br><span class="line">  (<span class="string">&#x27;Jeru&#x27;</span>, <span class="string">&#x27;Gerry Mulligan&#x27;</span>, <span class="number">17.99</span>),</span><br><span class="line">  (<span class="string">&#x27;Sarah Vaughan&#x27;</span>, <span class="string">&#x27;Sarah Vaughan&#x27;</span>, <span class="number">34.98</span>);</span><br></pre></td></tr></table></figure><p>在上述 SQL 代码中, 你进行了以下几项操作:</p><ul><li>删除(drop)名为 <code>album</code> 的数据表. 首先执行这个命令主要是为了在日后重新创建这个数据表时, 可以更简单地重新运行这个脚本.</li><li>创建一个 <code>album</code> 表, 包含四个列: <code>title</code>, <code>artist</code>, <code>price</code> 和 <code>id</code>. 每一行的 <code>id</code> 列由 DBMS 自动创建.</li><li>添加四行数据.</li></ul><p>7.在 <code>mysql</code> 命令提示符中, 运行你刚刚创建的脚本:</p><p>你将按照以下格式使用 <code>source</code> 命令: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">source</span> /path/to/create-tables.sql</span><br></pre></td></tr></table></figure><p>8.在你的 DBMS 命令提示符中, 使用 <code>SELECT</code> 语句来验证你成功创建的数据表和数据.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from album;</span><br><span class="line">+----+---------------+----------------+-------+</span><br><span class="line">| id | title         | artist         | price |</span><br><span class="line">+----+---------------+----------------+-------+</span><br><span class="line">|  1 | Blue Train    | John Coltrane  | 56.99 |</span><br><span class="line">|  2 | Giant Steps   | John Coltrane  | 63.99 |</span><br><span class="line">|  3 | Jeru          | Gerry Mulligan | 17.99 |</span><br><span class="line">|  4 | Sarah Vaughan | Sarah Vaughan  | 34.98 |</span><br><span class="line">+----+---------------+----------------+-------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>下一步, 你将编写一些 Go 代码来连接数据库, 以便进行数据查询.</p><p><br/></p><h2 id="查找并导入数据库驱动"><a href="#查找并导入数据库驱动" class="headerlink" title="查找并导入数据库驱动"></a>查找并导入数据库驱动</h2><p>现在你有一个数据库, 并且里面存储了一些数据. 下面开始编写你的 Go 代码.</p><p>找出并导入一个数据库驱动, 你通过 <code>database/sql</code> 库的函数创建的请求, 将会被翻译成为数据库可以理解的请求.</p><p>1.在浏览器中, 打开 <a href="https://github.com/golang/go/wiki/SQLDrivers">SQLDrivers</a> wiki 页面, 找到一个你可以使用的驱动.<br>从这个页面中的列表找到一个你要用的驱动. 本教程中你将会使用 <a href="https://github.com/go-sql-driver/mysql/">Go-MySQL-Driver</a> 来访问数据库.</p><p>2.注意这里用到的驱动包名, <code>github.com/go-sql-driver/mysql</code>.</p><p>3.使用你的文本编辑器, 创建一个名为 main.go 的文件用来编写 Go 代码, 并保存在你之前创建的 data-access 目录中.</p><p>4.在 main.go 中, 粘贴如下代码导入驱动包:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下操作:</p><ul><li>将你的代码添加到 <code>main</code> 包中, 以便它可以独立运行.</li><li>导入 MySQL 驱动 <code>github.com/go-sql-driver/mysql</code></li></ul><p>导入驱动后, 你将要开始编写代码来访问数据库.</p><p><br/></p><h2 id="获取一个数据库句柄并进行连接"><a href="#获取一个数据库句柄并进行连接" class="headerlink" title="获取一个数据库句柄并进行连接"></a>获取一个数据库句柄并进行连接</h2><p>现在来编写一些代码, 通过一个数据库句柄, 让你获得数据库的入口.</p><p>你将要使用一个指向 <code>sql.DB</code> 结构体的指针, 来表示一个指定数据库的入口.</p><p><strong>编写代码</strong></p><p>1.打开 main.go 文件, 在你刚刚添加的 <code>import</code> 代码的下方, 粘贴如下 Go 代码来创建一个数据库句柄:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cfg := mysql.Config&#123;</span><br><span class="line">        User:   os.Config&#123;</span><br><span class="line">            User:   os.Getenv(<span class="string">&quot;DBUSER&quot;</span>),</span><br><span class="line">            Passwd: os.Getenv(<span class="string">&quot;DBPASS&quot;</span>),</span><br><span class="line">            Net:    <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">            Addr:   <span class="string">&quot;127.0.0.1:3306&quot;</span>,</span><br><span class="line">            DBName: <span class="string">&quot;recordings&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get a database handle</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, cfg.FormatDSN())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pingErr := db.Ping()</span><br><span class="line">    <span class="keyword">if</span> pingErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(pingErr)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Connected!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下几个操作:</p><ul><li>声明了一个 <code>*sql.DB</code> 类型的 <code>db</code> 变量. 这就是你的数据库句柄.</li></ul><p>把 <code>db</code> 变量作为全局变量, 简化了这个示例. 但是在生产代码中, 你应该避免使用全局变量, 例如将变量作为参数传入函数, 或者将其包装在一个结构体内.</p><ul><li>使用 MySQL 驱动的 <code>Config</code> 和 <code>FormatDSN</code> , 把连接的属性集中在一起, 并将他们格式化成 DSN (Database Source Name) 格式, 成为一个连接字符串.</li></ul><p>相比于一个连接字符串, <code>Config</code> 结构体使得代码的可读性更强.</p><ul><li><p>调用 <code>sql.Open</code> 来初始化 <code>db</code> 变量, 传入 <code>FormatDSN</code> 的返回值.</p></li><li><p>检查 <code>sql.Open</code> 返回的异常. <code>sql.Open</code> 有可能会失败, 比如, 当你的数据库连接属性不符合规范的时候.</p></li></ul><p>为了简化代码, 你调用了 <code>log.Fatal</code> 来终止代码的运行, 并向控制台输出异常信息. 在生产代码中, 你可能会希望用更平滑的方式来处理异常.</p><ul><li><p>调用 <code>DB.Ping</code> 以确认和数据库的连接是否正常. 在运行时, <code>sql.Open</code> 可能不会立即建立连接, 这取决于驱动. 你在这里使用 <code>Ping</code> 来确认确保 <code>database/sql</code> 包在需要的时候可以连接到数据库.</p></li><li><p>检查 <code>Ping</code> 返回的异常, 假如连接失败的话.</p></li><li><p>如果 <code>Ping</code> 连接成功, 打印一条信息.</p></li></ul><p>2.在 main.go 文件的顶部, 紧挨着 package 声明的下方, 导入所有你在刚刚编写的那段代码中用到的包.</p><p>编辑后的文件顶部代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>3.保存 main.go</p><p><strong>运行代码</strong></p><ol><li>将 MySQL 驱动模块作为依赖进行追踪.</li></ol><p>使用 <code>go get</code> 命令来把 github.com/go-sql-driver/mysql 模块作为你自己模块的依赖添加进来. 使用 <code>.</code> 参数的意思是“获取当前目录中代码的依赖”.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get .</span><br><span class="line">go get: added github.com/go-sql-driver/mysql v1.6.0</span><br></pre></td></tr></table></figure><p>Go 完成了对这个依赖的下载, 是因为你在之前的步骤中把它添加到了 <code>import</code> 声明里. 更多关于依赖跟踪的的内容, 请见 <a href="https://go.dev/doc/modules/managing-dependencies#adding_dependency">Adding a dependency</a>.</p><p>2.在命令提示符界面, 设置 Go 程序需要用到的 <code>DBUSER</code> 和 <code>DBPASS</code> 环境变量.</p><p>在 Linux 或 Mac 系统上执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> DBUSER=username</span><br><span class="line">$ <span class="built_in">export</span> DBPASS=password</span><br></pre></td></tr></table></figure><p>在 Windows 系统上执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\you\daa-access&gt; <span class="built_in">set</span> DBUSER=username</span><br><span class="line">C:\Users\you\daa-access&gt; <span class="built_in">set</span> DBPASS=password</span><br></pre></td></tr></table></figure><p>3.在命令行中, 包含 main.go 的目录下, 输入 <code>go run</code> 命令和点参数(<code>.</code>)来运行代码. 这行命令的含义是“在当前目录下运行这个包”.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Connected!</span><br></pre></td></tr></table></figure><p>你可以连接数据库了! 下一步, 你将要完成对一些数据的查询.</p><p><br/></p><h2 id="查询多行记录"><a href="#查询多行记录" class="headerlink" title="查询多行记录"></a>查询多行记录</h2><p>在这一小节, 你讲使用 Go 来运行一条查询并返回多行数据的 SQL 语句.</p><p>对于可能返回多行数据的 SQL 语句, 你使用 <code>database/sql</code> 包中的 <code>Query</code> 方法, 然后遍历返回的数据行.(你稍后会在 <a href="https://go.dev/doc/tutorial/database-access#single_row">Query for a single row</a> 中学习如何查询单行数据.)</p><p><strong>编写代码</strong></p><p>1.打开 main.go 文件, 在紧挨着 <code>func main</code> 的上方, 粘贴如下代码, 定义一个 <code>Album</code> 结构体. 你将使用这个结构体来储存查询返回的数据行.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Album <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="keyword">int64</span></span><br><span class="line">    Title   <span class="keyword">string</span></span><br><span class="line">    Artist  <span class="keyword">string</span></span><br><span class="line">    Price   <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在 <code>func main</code> 的下方, 粘贴下面的 <code>albumsByArtist</code> 函数用于查询数据库.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// albumsByArtist 用来查询拥有指定艺术家名称的专辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">albumsByAritist</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">([]Album, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 一个用来保存返回的数据行的 albums slice</span></span><br><span class="line">    <span class="keyword">var</span> albums []Album</span><br><span class="line"></span><br><span class="line">    rows, err := db.Query(<span class="string">&quot;SELECT * FROM album WHERE artist = ?&quot;</span>, name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;albumsByArtist %q: %v&quot;</span>, name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line">    <span class="comment">// 遍历数据行, 使用 Scan 来将每列的数据赋值到结构体的字段上.</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> alb Album</span><br><span class="line">        <span class="keyword">if</span> err := rows.Scan(&amp;alb.ID, &amp;alb.Title, &amp;alb.Artist, &amp;alb.Price); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;albumsByArtist %q: %v&quot;</span>, name, err)</span><br><span class="line">        &#125;</span><br><span class="line">        albums = <span class="built_in">append</span>(albums, alb)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;albumsByAritst %q: %v&quot;</span>, name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> albums, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你完成了以下几项操作:</p><ul><li><p>声明了一个你定义的 <code>Album</code> 类型的切片变量 <code>albums</code>. 这个切片将用来保存返回的数据行中的数据. 结构体字段名称和类型与数据库列的名称以及类型相对应.</p></li><li><p>使用 <code>DB.Query</code> 执行 <code>SELECT</code> 语句, 对指定艺术家名称的专辑进行查询.</p></li></ul><p><code>Query</code> 的第一个参数是 SQL 语句. 在这个参数的后面, 你可以传入零个或多个任意类型的参数. 这给你提供了一个可以为 SQL 语句指定参数值的位置. 通过将 SQL 语句和参数值拆分开 (而不是使用 <code>fmt.Printf</code> 拼接在一起), <code>database/sql</code> 包可以将 SQL 语句文本和值分开传递, 避免了 SQL 注入的风险.</p><ul><li><p>使用 Defer 关闭 <code>rows</code>, 使它持有的资源 可以在函数退出时释放.</p></li><li><p>遍历返回的全部数据行, 使用 <code>Rows.Scan</code> 来将每个数据行中各列的数据赋值到 <code>Album</code> 结构体的字段中.</p></li></ul><p><code>Scan</code> 接收一系列 Go 值的指针, 各列的值将会写入这些指针指向的位置. 在这里, 你使用 <code>&amp;</code> 操作符创建了指向 <code>alb</code> 变量中不同字段的指针, 并将它们传入 <code>Scan</code> 中. <code>Scan</code> 通过这些指针写入数据, 对结构体的字段进行更新.</p><ul><li><p>在循环中, 校验列数据赋值到结构体字段时返回的异常.</p></li><li><p>在循环中, 把新的 <code>alb</code> 追加到 <code>albums</code> 切片中.</p></li><li><p>在循环之后, 使用 <code>rows.Err</code> 校验整个查询过程中的异常, 注意如果查询本身失败了, 而想要发现结果不完整, 在这里进行异常校验是唯一的方式.</p></li></ul><p>3.更新你的 <code>main</code> 函数, 对 <code>albumsByArtist</code> 进行调用.</p><p>向 <code>func main</code> 的末尾, 添加如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albums, err := albumsByArtist(<span class="string">&quot;John Coltrane&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Albums found: %v\n&quot;</span>, albums)</span><br></pre></td></tr></table></figure><p>在新增的代码中, 你现在完成了以下操作:</p><ul><li>调用你添加的 <code>albumsByArtist</code> 函数, 将返回值赋值到新的 <code>albums</code> 变量上.</li><li>打印结果</li></ul><p><strong>运行代码</strong></p><p>打开命令行, 在 main.go 所在的目录下, 运行代码.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Connected!</span><br><span class="line">Albums found: [&#123;1 Blue Train John Coltrane 56.99&#125; &#123;2 Giant Steps John Coltrane 63.99&#125;]</span><br></pre></td></tr></table></figure><p>下一步, 你将会查询单行数据.</p><p><br/></p><h2 id="查询单行记录"><a href="#查询单行记录" class="headerlink" title="查询单行记录"></a>查询单行记录</h2><p>在本小节, 你将使用 Go 来完成对数据库中单行数据的查询.</p><p>对于你已知的最多只会返回一个数据行的 SQL 语句, 你可以使用 <code>QueryRow</code>, 这样比使用 <code>Query</code> 循环更加简单.</p><p><strong>编写代码</strong></p><p>1.在 <code>albumsByArtist</code> 的下方, 粘贴 <code>albumByID</code> 函数代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// albumByID 通过指定 ID 查询专辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">albumByID</span><span class="params">(id <span class="keyword">int64</span>)</span> <span class="params">(Album, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 保存查询返回的专辑数据</span></span><br><span class="line">    <span class="keyword">var</span> alb Album</span><br><span class="line"></span><br><span class="line">    row := db.QueryRow(<span class="string">&quot;SELECT * FROM album WHERE id = ?&quot;</span>, id)</span><br><span class="line">    <span class="keyword">if</span> err := row.Scan(&amp;alb.ID, &amp;alb.Title, &amp;alb.Artist, &amp;alb.Price); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">            <span class="keyword">return</span> alb, fmt.Errorf(<span class="string">&quot;albumsById %d: no such album&quot;</span>, id)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> alb, fmt.Errorf(<span class="string">&quot;albumsById %d: %v&quot;</span>, id, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> alb, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你完成了以下操作:</p><ul><li>使用 <code>DB.QueryRow</code> 执行了 <code>SELECT</code> 语句, 根据指定的 ID 对专辑进行查询.</li></ul><p><code>DB.QueryRow</code> 返回了一个 <code>sql.Row</code>. 为了简化你的代码, <code>QueryRow</code> 并没有返回异常. 而是把查询异常(比如 <code>sql.ErrNoRows</code>)放到了 <code>Rows.Scan</code> 后面.</p><ul><li><p>使用 <code>Row.Scan</code> 将每列的值赋值到结构体字段中</p></li><li><p>校验 <code>Scan</code> 返回的异常</p></li></ul><p>这个特殊的 <code>sql.ErrNoRows</code> 异常表示查询没有任何一条结果返回. 这个异常通常有必要使用更明确的文本信息替代, 比如这里的 “no such album”.</p><p>2.更新 <code>main</code> 函数, 对 <code>albumByID</code> 进行调用</p><p>向 <code>func main</code> 的末尾, 添加如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里硬编码 ID 为 2 用于查询测试</span></span><br><span class="line">alb, err := albumByID(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Album found: %v\n&quot;</span>, alb)</span><br></pre></td></tr></table></figure><p>在这段新增代码中, 你完成了以下操作:</p><ul><li>调用了你添加的 <code>albumByID</code> 函数</li><li>打印了这个专辑 ID 的返回值</li></ul><p><strong>运行代码</strong></p><p>打开命令行, 在 main.go 所在的目录, 运行代码.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Connected!</span><br><span class="line">Albums found: [&#123;1 Blue Train John Coltrane 56.99&#125; &#123;2 Giant Steps John Coltrane 63.99&#125;]</span><br><span class="line">Album found: &#123;2 Giant Steps John Coltrane 63.99&#125;</span><br></pre></td></tr></table></figure><p>下一步, 你将会添加一条专辑信息到数据库中.</p><p><br/></p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>在本小节, 你将使用 Go 执行 SQL 的 <code>INSERT</code> 语句, 来添加一条新数据到数据库中.</p><p>你已经了解到了如何使用 <code>Query</code> 和 <code>QueryRow</code> 两个有返回数据的函数来执行 SQL 语句. 那么对于不返回数据的 SQL 语句, 你需要使用 <code>Exec</code></p><p><strong>编写代码</strong></p><p>1.在 <code>albumByID</code> 函数的下方, 粘贴 <code>addAlbum</code> 函数的代码如下, 用于添加一条新的专辑数据到数据库中, 然后保存 main.go 文件.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addAlbum 添加指定的专辑信息到数据库中</span></span><br><span class="line"><span class="comment">// 返回新数据到专辑 ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAlbum</span><span class="params">(alb Album)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">    result, err := db.Exec(<span class="string">&quot;INSERT INTO album (title, artist, price) VALUES (?, ?, ?)&quot;</span>, alb.Title, alb.Artist, alb.Price)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;addAlbum: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    id, err := result.LastInsertId()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;addAlbum: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你完成了以下操作:</p><ul><li>使用 <code>DB.Exec</code> 执行了 <code>INSERT</code> 语句<br>就像 <code>Query</code> 一样, <code>Exec</code> 接收 SQL 语句和这个 SQL 语句的参数值.</li><li>校验尝试执行 <code>INSERT</code> 语句时返回的异常</li><li>使用 <code>Result.LastInsertId</code> 取回新插入数据的 ID.</li><li>校验尝试取回 ID 时返回的异常.</li></ul><p>2.更新 <code>main</code> 函数对新增的 <code>addAlbum</code> 函数进行调用.</p><p>向 <code>func main</code> 的末尾, 添加如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albID, err := addAlbum(Album&#123;</span><br><span class="line">    Title:  <span class="string">&quot;The modern Sound of Betty Carter&quot;</span>,</span><br><span class="line">    Artist: <span class="string">&quot;Betty Carter&quot;</span>,</span><br><span class="line">    Price:  <span class="number">49.99</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ID of added album: %v\n&quot;</span>, albID)</span><br></pre></td></tr></table></figure><p>在这段新增代码中, 你现在完成了以下操作:</p><ul><li>调用 <code>addAlbum</code> 并使用一个新专辑信息作为参数, 将你添加的专辑信息 ID 赋值给一个 <code>albID</code> 变量.</li></ul><p><strong>运行代码</strong></p><p>打开命令行, 在 main.go 所在的目录下, 运行代码.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Connected!</span><br><span class="line">Albums found: [&#123;1 Blue Train John Coltrane 56.99&#125; &#123;2 Giant Steps John Coltrane 63.99&#125;]</span><br><span class="line">Album found: &#123;2 Giant Steps John Coltrane 63.99&#125;</span><br><span class="line">ID of added album: 5</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>恭喜你! 你刚刚使用 Go 完成了一些对关系型数据库的简单操作.</p><p>接下来的一些建议:</p><ul><li>阅读一下数据存取指南(data access guide), 有一些本教程仅仅浅尝辄止的内容, 在数据存取指南中有更详细的介绍.</li><li>如果你刚刚开始使用 Go, 你可以在 <a href="https://go.dev/doc/effective_go">Effective Go</a> 和 <a href="https://go.dev/doc/code">How to wirte Go code</a> 中找到非常有用的 Go 语言最佳实践.</li><li><a href="https://tour.golang.org/welcome/1">Go Tour</a> 是一个非常好的入门教程, 循序渐进地介绍了 Go 语言的基础.</li></ul><p><br/></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>本小节包含了你跟随本教程构建的程序的完整代码.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Album <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int64</span></span><br><span class="line">    Title  <span class="keyword">string</span></span><br><span class="line">    Artist <span class="keyword">string</span></span><br><span class="line">    Price  <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Capture connection properties.</span></span><br><span class="line">    cfg := mysql.Config&#123;</span><br><span class="line">        User:   os.Getenv(<span class="string">&quot;DBUSER&quot;</span>),</span><br><span class="line">        Passwd: os.Getenv(<span class="string">&quot;DBPASS&quot;</span>),</span><br><span class="line">        Net:    <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">        Addr:   <span class="string">&quot;127.0.0.1:3306&quot;</span>,</span><br><span class="line">        DBName: <span class="string">&quot;recordings&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get a database handle.</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, cfg.FormatDSN())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pingErr := db.Ping()</span><br><span class="line">    <span class="keyword">if</span> pingErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(pingErr)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Connected!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    albums, err := albumsByArtist(<span class="string">&quot;John Coltrane&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Albums found: %v\n&quot;</span>, albums)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hard-code ID 2 here to test the query.</span></span><br><span class="line">    alb, err := albumByID(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Album found: %v\n&quot;</span>, alb)</span><br><span class="line"></span><br><span class="line">    albID, err := addAlbum(Album&#123;</span><br><span class="line">        Title:  <span class="string">&quot;The Modern Sound of Betty Carter&quot;</span>,</span><br><span class="line">        Artist: <span class="string">&quot;Betty Carter&quot;</span>,</span><br><span class="line">        Price:  <span class="number">49.99</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;ID of added album: %v\n&quot;</span>, albID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// albumsByArtist queries for albums that have the specified artist name.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">albumsByArtist</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">([]Album, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// An albums slice to hold data from returned rows.</span></span><br><span class="line">    <span class="keyword">var</span> albums []Album</span><br><span class="line"></span><br><span class="line">    rows, err := db.Query(<span class="string">&quot;SELECT * FROM album WHERE artist = ?&quot;</span>, name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;albumsByArtist %q: %v&quot;</span>, name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line">    <span class="comment">// Loop through rows, using Scan to assign column data to struct fields.</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> alb Album</span><br><span class="line">        <span class="keyword">if</span> err := rows.Scan(&amp;alb.ID, &amp;alb.Title, &amp;alb.Artist, &amp;alb.Price); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;albumsByArtist %q: %v&quot;</span>, name, err)</span><br><span class="line">        &#125;</span><br><span class="line">        albums = <span class="built_in">append</span>(albums, alb)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;albumsByArtist %q: %v&quot;</span>, name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> albums, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// albumByID queries for the album with the specified ID.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">albumByID</span><span class="params">(id <span class="keyword">int64</span>)</span> <span class="params">(Album, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// An album to hold data from the returned row.</span></span><br><span class="line">    <span class="keyword">var</span> alb Album</span><br><span class="line"></span><br><span class="line">    row := db.QueryRow(<span class="string">&quot;SELECT * FROM album WHERE id = ?&quot;</span>, id)</span><br><span class="line">    <span class="keyword">if</span> err := row.Scan(&amp;alb.ID, &amp;alb.Title, &amp;alb.Artist, &amp;alb.Price); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">            <span class="keyword">return</span> alb, fmt.Errorf(<span class="string">&quot;albumsById %d: no such album&quot;</span>, id)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> alb, fmt.Errorf(<span class="string">&quot;albumsById %d: %v&quot;</span>, id, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> alb, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addAlbum adds the specified album to the database,</span></span><br><span class="line"><span class="comment">// returning the album ID of the new entry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAlbum</span><span class="params">(alb Album)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">    result, err := db.Exec(<span class="string">&quot;INSERT INTO album (title, artist, price) VALUES (?, ?, ?)&quot;</span>, alb.Title, alb.Artist, alb.Price)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;addAlbum: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    id, err := result.LastInsertId()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;addAlbum: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 泛型入门(译)</title>
      <link href="/2022/06/06/golang/getting-started-with-generics/"/>
      <url>/2022/06/06/golang/getting-started-with-generics/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><blockquote><p>原文: <a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a></p></blockquote><p>本教程介绍 Go 语言泛型(Generics)的基础知识. 通过使用泛型, 你可以声明并使用一些特殊的函数(functions)或者数据类型(types), 它们可以对某些类型的集合中任意一个类型生效.</p><p>在本篇教程中, 你将会声明两个“非泛型(non-generics)”的函数, 然后将其中相同的逻辑迁移到使用泛型实现的单个函数中.</p><p>你将会按照以下几个小节, 循序渐进地进行学习:</p><ol><li>为你的代码创建目录</li><li>添加非泛型函数</li><li>添加一个泛型函数来处理多种数据类型</li><li>在调用泛型函数时移除类型实参</li><li>声明一个类型约束(type constraint)</li></ol><p><strong>Note:</strong> 其他教程, 见 <a href="https://go.dev/doc/tutorial/index.html">Tutorials</a></p><p><strong>Note:</strong> 你可以根据喜好, 选择使用 <a href="https://go.dev/play/?v=gotip">Go playground</a> 来编辑和运行你的代码.</p><p><br/></p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li><strong>已安装 Go 语言 1.18 或更新版本.</strong> 更多安装说明, 见 <a href="https://go.dev/doc/install">Installing Go</a></li><li><strong>代码编辑器.</strong> 任何你已有的文本编辑器都可以满足需求.</li><li><strong>命令行终端.</strong> Go 可以在 Linux 或 Mac 终端正常工作, 也可以在 Windows 的 PowerShell 或 cmd 中运行.</li></ul><p><br/></p><h2 id="为你的代码创建目录"><a href="#为你的代码创建目录" class="headerlink" title="为你的代码创建目录"></a>为你的代码创建目录</h2><p>为了开始编写代码, 你需要先创建一个目录.</p><p>1.打开命令行, 进入到 Home 目录</p><p>在 Linux 或者 Mac 上执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span></span><br></pre></td></tr></table></figure><p>或在 Windows 上执行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; <span class="built_in">cd</span> %HOMEPATH%</span><br></pre></td></tr></table></figure><p>下文将仅使用 <code>$</code> 表示命令提示符. 所有命令在 Windows 系统也都同样可以运行.</p><p>2.在命令提示符后面输入命令, 为代码创建一个目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir generics</span><br><span class="line">$ <span class="built_in">cd</span> generics</span><br></pre></td></tr></table></figure><p>3.创建一个模块用于组织代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init example/generics</span><br><span class="line">go: creating new go.mod: module example/generics</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 在生产代码中, 最好根据你的需求指定一个更具体的模块路径(module path). 更多详情, 请务必阅读 <a href="https://go.dev/doc/modules/managing-dependencies">依赖管理</a>.</p><p>下一步, 你将要添加一些和 map 类型相关的简单代码</p><p><br/></p><h2 id="添加非泛型函数"><a href="#添加非泛型函数" class="headerlink" title="添加非泛型函数"></a>添加非泛型函数</h2><p>在本小节中, 你将要添加两个函数, 这两个函数的逻辑都是将 map 中的所有值累加并返回结果.</p><p>之所以需要添加两个函数, 而不是一个, 是因为这两个函数需要用于两个不同类型的 map: 一个存储的是 <code>int64</code> 类型的值, 一个存储的是 <code>float64</code> 类型的值.</p><p><strong>编写代码</strong></p><p>1.在刚刚创建好的目录中, 使用文本编辑器创建一个名为 <code>main.go</code> 的文件. 在这个文件中编写你的代码.<br>2.在 <code>main.go</code> 文件的首行, 粘贴如下 package(包) 声明:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure><p>独立运行的程序(相较于库(library)来说)都需要在 <code>main</code> 包里面.</p><p>3.在 package 声明下方, 粘贴如下两个函数声明的代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SumInts 将 m 中的所有值进行累加.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumInts</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SumFloats 对 m 中的所有值进行累加.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumFloats</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">float64</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下几个操作:</p><ul><li>声明了两个函数, 对 map 中的值进行累加并返回结果<ul><li><code>SumFloats</code> 接收一个 key 为 <code>string</code> 类型, 值为 <code>float64</code> 类型的 map</li><li><code>SumInts</code> 接收一个 key 为 <code>string</code> 类型, 值为 <code>int64</code> 类型的 map</li></ul></li></ul><p>4.在 main.go 文件中, 紧跟着 package 声明的下方, 插入如下代码. 这段代码实现了一个 <code>main</code> 函数, 其中初始化了两个 map 对象, 并且在调用上一步中声明的两个函数时, 分别将这两个 map 对象作为参数传入.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个值为整型的 map</span></span><br><span class="line">    ints := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;</span><br><span class="line">        <span class="string">&quot;first&quot;</span>: <span class="number">34</span>,</span><br><span class="line">        <span class="string">&quot;second&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个值为浮点型的 map</span></span><br><span class="line">    floats := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>&#123;</span><br><span class="line">        <span class="string">&quot;first&quot;</span>: <span class="number">35.98</span>,</span><br><span class="line">        <span class="string">&quot;second&quot;</span>: <span class="number">26.99</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Non-Generic Sums: %v and %v\n&quot;</span>,</span><br><span class="line">        SumInts(ints),</span><br><span class="line">        SumFloats(floats))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中, 你进行了以下几个操作:</p><ul><li>初始化了一个值为 <code>float64</code> 类型的 map 对象, 和一个值为 <code>int64</code> 类型的 map 对象, 它们各自有两条记录(entries).</li><li>对你之前声明的这两个函数进行调用, 分别对两个 map 对象的值求和</li><li>打印结果</li></ul><p>5.在 main.go 文件顶部, 紧挨着 package 声明的位置, 导入你刚刚在代码中使用对 package.<br>前几行代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure><p>6.保存 main.go 文件</p><p><strong>运行代码</strong></p><p>打开命令行, 在 main.go 文件的目录下执行如下命令运行代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Non-Generic Sums: 46 and 62.97</span><br></pre></td></tr></table></figure><p>通过使用泛型, 你可以仅仅写一个函数来替代上面的两个函数. 接下来, 你将会学习添加一个简单的泛型函数, 用于处理 map 类型的对象, 无论它包含的值整型还是浮点型.</p><p><br/></p><h2 id="添加一个泛型函数来处理多种数据类型"><a href="#添加一个泛型函数来处理多种数据类型" class="headerlink" title="添加一个泛型函数来处理多种数据类型"></a>添加一个泛型函数来处理多种数据类型</h2><p>在本小节, 你将向代码中添加一个泛型函数, 接收一个 map 类型作为参数, 而 map 中的值既可以是整型, 也可以是浮点型, 以此来有效地使用一个单独函数替换刚刚创建的两个函数.</p><p>为了支持两种数据类型中的任意一个, 这个单独的函数需要使用一种方式来声明它可以支持的类型. 换句话说, 调用的代码需要通过一种方式来知道它接收的是整型还是浮点型.</p><p>为了实现这个功能, 就需要在函数原有形参的基础上额外添加 <em>类型形参(type parameters)</em>. 这些类型形参让原本的函数获得了通用性, 使其可以接受不同类型的实参(arguments). 在调用这个函数的时候, 也需要带上 <em>类型实参(type arguments)</em> 和函数原本的实参.</p><p>每个类型形参都有一个类型约束(type constraint), 它的作用就像是这个类型形参的元类型(meta-type). 每个类型约束都指定了函数调用时每个类型形参允许对应传入的类型实参.</p><p>尽管类型形参的约束一般都代表着一系列类型的集合, 但是在编译时类型形参只能表示一种类型 —— 即函数调用时提供的类型实参的类型. 如果类型实参的类型不被类型约束所允许, 代码则将不能进行编译.</p><p>一定要注意的是, 一个类型形参一定要支持通用代码对它进行的所有操作. 举个例子, 如果你的函数代码尝试对类型形参执行 <code>string</code> 类型的操作(比如索引取值), 然而类型形参的类型约束包含数字类型, 代码将不能进行编译.</p><p>在接下来要写的代码中, 将要使用一个既允许整型, 也允许浮点型的类型约束.</p><p><strong>编写代码</strong></p><p>1.在你之前添加的两个函数下方, 粘贴下面的泛型函数代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SumIntsOrFloats 对 map 对象 m 的值进行求和, 同时支持值为 int64 和 float64 类型的 map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumIntsOrFloats</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">int64</span> | <span class="title">float64</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s V</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下几个操作:</p><ul><li>声明了一个 <code>SumIntsOrFloats</code> 函数, 它有两个类型形参(在方括号中) <code>K</code> 和 <code>V</code>, 和一个使用了类型形参的函数形参, <code>map[K]V</code> 类型的 <code>m</code>. 函数返回一个类型为 <code>V</code> 的值.  </li><li>为类型形参 <code>K</code> 指定了类型约束 <code>comparable</code>. 为了这样的场景, Go 语言中专门预先声明了 <code>comparable</code> 约束. 任何一个类型, 如果它的值可以作为比较操作符 <code>==</code> 和 <code>!=</code> 的操作数, 那么它都受到约束的认可. Go 语言规定 map 类型的 key 是 comparable (可比较) 的. 所以为了能够使用 <code>K</code> 作为 map 变量的 key, 有必要将 <code>K</code> 声明为 <code>comparable</code>. 同时它也确保了代码中使用的类型是可以作为 map 类型的 key 的.  </li><li>为类型形参 <code>V</code> 指定了一个由两个类型的并集组成的类型约束, 这两个类型分别是: <code>int64</code> 和 <code>float64</code>. 使用 <code>|</code> 指定两个类型的并集, 意味着这个类型约束接受这两个类型中的任意一个. 在调用代码时, 使用这两个类型中任意一个类型的值作为实参, 编译器都是允许的.</li><li>指定 <code>m</code> 参数为 <code>map[K]V</code> 类型, 而 <code>K</code> 和 <code>V</code> 已经在类型形参中指定了. 注意, 由于 <code>K</code> 是一个 comparable 类型, 所以我们知道 <code>map[K]V</code> 是一个合法的 map 类型. 如果我们没有声明 <code>K</code> 是 comparable 类型, 那么编译器将拒绝对 <code>map[K]V</code> 的引用.</li></ul><p>2.在 main.go 文件中, 向已有的代码下方继续粘贴如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;Generic Sums: %v and %v\n&quot;</span>,</span><br><span class="line">    SumIntsOrFloats[<span class="keyword">string</span>, <span class="keyword">int64</span>](ints),</span><br><span class="line">    SumIntsOrFloats[<span class="keyword">string</span>, <span class="keyword">float64</span>](floats))</span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下几个操作:</p><ul><li>调用了你刚才声明的泛型函数, 分别将你创建的两个 map 对象作为实参传入.</li><li>指定了类型实参 —— 方括号中的类型名称 —— 明确了你调用代码时需要替换类型形参的数据类型. 你将在下一小节看到, 在函数调用时类型实参通常可以被省略. Go 通常可以通过你的代码来推断出类型实参.</li><li>打印函数返回的值.</li></ul><p><strong>运行代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Non-Generic Sums: 46 and 62.97</span><br><span class="line">Generic Sums: 46 and 62.97</span><br></pre></td></tr></table></figure><p>为了使你的代码可以运行, 编译器在每次函数调用时都会使用你指定的具体数据类型来替换类型形参.</p><p>在调用你实现的泛型函数时, 你通过指定类型实参, 来告诉编译器使用哪些类型来替换函数的类型形参. 你将在下一节看到, 在很多场景下, 由于编译器可以推断出类型实参, 因此你可以省略它们.</p><p><br/></p><h2 id="在调用泛型函数时移除类型实参"><a href="#在调用泛型函数时移除类型实参" class="headerlink" title="在调用泛型函数时移除类型实参"></a>在调用泛型函数时移除类型实参</h2><p>在本小节, 你将会添加一个修改版本的泛型函数调用, 通过一点小小的改动使代码更加简单. 你将要移除在这个场景下并不需要的类型实参.</p><p>注意, 类型实参并不总是可以省略的. 举个例子, 如果你需要调用一个没有实参的泛型函数, 你就需要在进行函数调用时带上类型实参.</p><p><strong>编写代码</strong></p><ul><li>在 main.go 文件中, 向已有代码的下方粘贴如下代码:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;Generic Sums, type parameters inferred: %v and %v\n&quot;</span>,</span><br><span class="line">    SumIntsOrFloats(ints),</span><br><span class="line">    SumIntsOrFloats(floats))</span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下操作:</p><ul><li>调用了泛型函数, 省略了类型实参</li></ul><p><strong>运行代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Non-Generic Sums: 46 and 62.97</span><br><span class="line">Generic Sums: 46 and 62.97</span><br><span class="line">Generic Sums: <span class="built_in">type</span> parameters inferred: 46 and 62.97</span><br></pre></td></tr></table></figure><p>接下来, 你将会把整型和浮点型的并集, 保存成一个可复用的类型约束, 使其在其他代码中也可以使用.</p><p><br/></p><h2 id="声明一个类型约束"><a href="#声明一个类型约束" class="headerlink" title="声明一个类型约束"></a>声明一个类型约束</h2><p>1.在 <code>main</code> 函数和 import 语句之间, 粘贴如下代码, 声明一个类型约束:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int64</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下操作:</p><ul><li>声明了可以作为类型约束使用的 <code>Number</code> interface 类型</li><li><p>在 interface 内部声明了 <code>int64</code> 和 <code>float64</code> 的并集</p><p>本质上, 你是将函数声明中的类型并集, 转移到了一个新的类型约束中. 通过这种方式, 在你想要约束一个 <code>int64</code> 或者 <code>float64</code> 类型的时候, 你可以使用 <code>Number</code> 类型约束来替代 <code>int64 | float64</code>  的写法.</p></li></ul><p>2.在已有的函数下方, 添加如下的 <code>SumNumbers</code> 泛型函数</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumNumbers</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">Number</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s V</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下操作:</p><ul><li>声明了一个新的泛型函数, 逻辑和之前声明的泛型函数相同, 但是类型约束使用了新的 interface 类型来替代原来的并集. 和之前一样, 为参数和返回值使用了类型形参.</li></ul><p>3.在 main.go 文件中, 向已有代码的下方粘贴如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;Generic Sums with Constraint: %v and %v\n&quot;</span>,</span><br><span class="line">    SumNumbers(ints),</span><br><span class="line">    SumNumbers(floats))</span><br></pre></td></tr></table></figure><p>在这段代码中, 你进行了以下操作:</p><ul><li>调用 <code>SumNumbers</code> 函数, 并分别使用两个 map 对象作为实参, 并打印求和结果.</li></ul><p>和之前的小节一样, 在调用泛型函数时, 你省略了类型实参(方括号中的类型名称). Go 编译器可以根据其他实参推断类型实参.</p><p><strong>运行代码</strong></p><p>打开命令行, 在 main.go 文件所在的目录中, 运行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Non-Generic Sums: 46 and 62.97</span><br><span class="line">Generic Sums: 46 and 62.97</span><br><span class="line">Generic Sums, <span class="built_in">type</span> parameters inferred: 46 and 62.97</span><br><span class="line">Generic Sums with Constraint: 46 and 62.97</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>干得漂亮! 你刚刚已经认识了 Go 泛型.</p><p>下一步的建议:</p><ul><li><a href="https://tour.golang.org/welcome/1">Go Tour</a> 是一个非常好的入门教程, 循序渐进地介绍了 Go 语言的基础.</li><li>你可以在 <a href="https://go.dev/doc/effective_go">Effective Go</a> 和 <a href="https://go.dev/doc/code">How to wirte Go code</a> 中找到非常有用的 Go 语言最佳实践.</li></ul><p><br/></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int64</span> | <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize a map for the integer values</span></span><br><span class="line">    ints := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;</span><br><span class="line">        <span class="string">&quot;first&quot;</span>: <span class="number">34</span>,</span><br><span class="line">        <span class="string">&quot;second&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize a map for the float values</span></span><br><span class="line">    floats := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>&#123;</span><br><span class="line">        <span class="string">&quot;first&quot;</span>: <span class="number">35.98</span>,</span><br><span class="line">        <span class="string">&quot;second&quot;</span>: <span class="number">26.99</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Non-Generic Sums: %v and %v\n&quot;</span>,</span><br><span class="line">        SumInts(ints),</span><br><span class="line">        SumFloats(floats))</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Generic Sums: %v and %v\n&quot;</span>,</span><br><span class="line">        SumIntsOrFloats[<span class="keyword">string</span>, <span class="keyword">int64</span>](ints),</span><br><span class="line">        SumIntsOrFloats[<span class="keyword">string</span>, <span class="keyword">float64</span>](floats))</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Generic Sums, type parameters inferred: %v and %v\n&quot;</span>,</span><br><span class="line">        SumIntsOrFloats(ints),</span><br><span class="line">        SumIntsOrFloats(floats))</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Generic Sums with Constraint: %v and %v\n&quot;</span>,</span><br><span class="line">        SumNumbers(ints),</span><br><span class="line">        SumNumbers(floats))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SumInts adds together the values of m.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumInts</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SumFloats adds together the values of m.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumFloats</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">float64</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SumIntsOrFloats sums the values of map m. It supports both floats and integers</span></span><br><span class="line"><span class="comment">// as map values.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumIntsOrFloats</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">int64</span> | <span class="title">float64</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s V</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SumNumbers sums the values of map m. Its supports both integers</span></span><br><span class="line"><span class="comment">// and floats as map values.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumNumbers</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">Number</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> <span class="title">V</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s V</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本篇内容是对技术文章翻译的第一次完整尝试, 如有错误, 欢迎邮件指正, 也欢迎邮件交流关于翻译的不同见解.<br>另外, 通常情况下 parameter 指函数声明时的形式参数名称,  argument 指函数调用时传入的实际参数. 但在本文中, argument 同时用与描述函数声明和函数调用的参数, 虽然两个单词都可以翻译为参数, 但无法直接体现出区别; 然而, 如果按照 parameter —— 形参, argument —— 实参 对应翻译, 似乎又不太正确. 这一点暂时存疑, 有待进一步的探究.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上弦月(初八)</title>
      <link href="/2022/06/05/astro-photography/2022-06-06-first-quarter-moon/"/>
      <url>/2022/06/05/astro-photography/2022-06-06-first-quarter-moon/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><p><img src="20220606_first_quarter_moon.jpeg" alt=""></p><p>设备: Explore Scientific 152/1900 mm 马卡 + EXOS-2 Goto 赤道仪<br>相机: 尼康 D700<br>时间: 2022-06-06 晚<br>地点: 小区南侧内部道路(无路灯)</p><blockquote><p>难得的好天气, 北斗七星清晰可见, 由于匆忙没来得及精确校准<br>下一次学习使用极轴镜对极轴, 尝试一星校准</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视星等与面亮度(译)</title>
      <link href="/2022/05/24/astro-photography/magnitude-and-surface-brightness/"/>
      <url>/2022/05/24/astro-photography/magnitude-and-surface-brightness/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><blockquote><p>来源: <a href="https://en.wikipedia.org/wiki/Surface_brightness">维基百科 - Surface Brightness</a></p><p>In astronomy, surface brightness (SB) quantifies the apparent brightness or flux density per unit angular area of a spatially extended object such as a galaxy or nebula, or of the night sky background. An object’s surface brightness depends on its surface luminosity density, i.e., its luminosity emitted per unit surface area. In visible and infrared astronomy, surface brightness is often quoted on a magnitude scale, in magnitudes per square arcsecond (MPSAS) in a particular filter band or photometric system.</p><p>Measurement of the surface brightnesses of celestial objects is called surface photometry.</p></blockquote><p>在天文学中, 面亮度 (Surface Brightness) 用来度量空间延展天体(extended object), 比如像星系(galaxy)或星云(nebula), 或者夜空背景(night sky background)单位角面积的视亮度(apparent brightness) 或者通量密度(flux density). 一个物体的面亮度取决于它的表面光度密度(luminosity density), 即它的每个单位表面区域发射出的光度. 在可见光及红外天文学(visible and infrared astronomy)中, 面亮度通常在特定滤光波段或者测光系统中, 以每平方角秒的星等标(magnitude scale)进行描述.</p><p>对天体(celestial objects)面亮度的测量, 称为面源测光(surface phtometry).</p><p>&lt;/br&gt;</p><h2 id="综合描述-General-Description"><a href="#综合描述-General-Description" class="headerlink" title="综合描述(General Description)"></a>综合描述(General Description)</h2><blockquote><p>The total magnitude is a measure of the brightness of an extended object such as a nebula, cluster, galaxy or comet. It can be obtained by summing up the luminosity over the area of the object. Alternatively, a photometer can be used by applying apertures or slits of different sizes of diameter. The background light is then subtracted from the measurement to obtain the total brightness. The resulting magnitude value is the same as a point-like source that is emitting the same amount of energy. The total magnitude of a comet is the combined magnitude of the coma and nucleus.</p></blockquote><p>总星等(total magnitude)是诸如星云、星系、星团或彗星一类延展天体的亮度度量. 它可以通过对整个天体区域的光度求和, 或者使用应用了不同尺寸光阑或狭缝的光度计(photometer)来进行测量, 然后减去背景光得到总亮度. 得到的星等值与发射同等能量的点状光源(point-like source)相同. 彗星的总星等是慧发(coma)和彗尾(nucleus)的合成星等(combined megnitude).</p><blockquote><p>The apparent magnitude of an astronomical object is generally given as an integrated value—if a galaxy is quoted as having a magnitude of 12.5, it means we see the same total amount of light from the galaxy as we would from a star with magnitude 12.5. However, a star is so small it is effectively a point source in most observations (the largest angular diameter, that of R Doradus, is 0.057 ± 0.005 arcsec), whereas a galaxy may extend over several arcseconds or arcminutes. Therefore, the galaxy will be harder to see than the star against the airglow background light. Apparent magnitude is a good indication of visibility if the object is point-like or small, whereas surface brightness is a better indicator if the object is large. What counts as small or large depends on the specific viewing conditions and follows from Ricco’s law. In general, in order to adequately assess an object’s visibility one needs to know both parameters.</p></blockquote><p>天体的视星等(apparent magnitude)通常是一个积分值(integrated value) —— 如果指明一个星系的星等为 12.5, 那么意味着我们从这个星系看到光的量, 与一颗同为 12.5 星等的恒星(star)相同. 然而, 一颗恒星非常的小, 在大多数观测中它实际上是一个点光源(point source) (<a href="https://en.wikipedia.org/wiki/R_Doradus">剑鱼座 R(R Doradus)</a>是角直径(angular diameter)最大的恒星, 它的角直径是 0.057 ± 0.005 角秒(arcsec)). 但是一个星系可能延展至几角秒或者角分(arcminutes). 因此, 在大气辉光背景(airglow background)下, 星系比恒星更难看到. 如果一个天体是点状的或很小的, 视星等是一个很好的可见度(visibility)指标, 但是如果天体非常大, 那么面亮度则是一个更好的指标. 大或小的评判取决于特定的观测条件, 并且遵循<a href="https://en.wikipedia.org/wiki/Ricco%27s_law">里科定律(Ricco’s low)</a>. 通常, 为了充分地评价一个天体的可见度, 同时需要这两个参数.</p><p>&lt;/br&gt;</p><h2 id="计算面亮度-Calculating-surface-brightness"><a href="#计算面亮度-Calculating-surface-brightness" class="headerlink" title="计算面亮度(Calculating surface brightness)"></a>计算面亮度(Calculating surface brightness)</h2><blockquote><p>Surface brightnesses are usually quoted in magnitudes per square arcsecond. Because the magnitude is logarithmic, calculating surface brightness cannot be done by simple division of magnitude by area. Instead, for a source with a total or integrated magnitude m extending over a visual area of A square arcseconds, the surface brightness S is given by</p><script type="math/tex; mode=display">S = m + 2.5 \cdot \log_10 A</script><p>For astronomical objects, surface brightness is analogous to photometric luminance and is therefore constant with distance: as an object becomes fainter with distance, it also becomes correspondingly smaller in visual area. In geometrical terms, for a nearby object emitting a given amount of light, radiative flux decreases with the square of the distance to the object, but the physical area corresponding to a given solid angle or visual area (e.g. 1 square arcsecond) decreases by the same proportion, resulting in the same surface brightness. For extended objects such as nebulae or galaxies, this allows the estimation of spatial distance from surface brightness by means of the distance modulus or luminosity distance.</p></blockquote><p>面亮度通常使用“星等每平方角秒”描述. 因为星等是对数的, 面亮度是不能简单通过星等除以面积来计算. 而是, 对于一个总星等或累积星等(integrated magnitude)为 $m$ 的光源, 可视面积扩展至 $A$ 平方角秒, 面亮度 $S$ 通过如下公式计算获得:</p><script type="math/tex; mode=display">S = m + 2.5 \cdot \log_10 A</script><p>对于天体来说, 面亮度类似于光度学的亮度(luminance), 不随着距离的改变而改变: 一个天体与我们距离越远, 就变得越暗淡, 同时它的视觉面积也相应地变小. 用几何学术语(geometrical terms)来说, 一个临近物体发射出一定量的光, 辐射通量随着与物体距离的平方值减小而减小, 它的立体角(solid angle)或可视区域相对应的物理面积也在以等比例减小, 最终结果是面亮度不变. 对于星云或星系一类的延展天体, 这个特性就允许我们借助<a href="https://en.wikipedia.org/wiki/Distance_modulus">距离模数(distance modulus)</a>或<a href="https://en.wikipedia.org/wiki/Luminosity_distance">光度距离(luminosity distance)</a>, 由面亮度估算空间距离.</p>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盈凸月(十四)</title>
      <link href="/2022/05/14/astro-photography/2022-05-14-waxing-gibbous-moon/"/>
      <url>/2022/05/14/astro-photography/2022-05-14-waxing-gibbous-moon/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><p><img src="waxing-gibbous-moon.jpeg" alt=""></p><p>设备: Explore Scientific 152/1900 mm 马卡 + EXOS-2 Goto 赤道仪<br>相机: 尼康 D700<br>时间: 2022-05-14 晚<br>地点: 阳台</p><blockquote><p>这一次调整了感光度, 消除了图片中的彩噪, 并且曝光处理在了正确的范围内<br>但是由于拍摄过程中存在抖动, 导致图片堆叠效果较差<br>最终选取了单张照片使用 PS 进行了防抖处理, 消除了单张图片中的抖动虚像<br>然后, 饱和度拉满 !!!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些年学校从未提及的 C 语言前置知识</title>
      <link href="/2022/04/09/c/overview/"/>
      <url>/2022/04/09/c/overview/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>毕业近 7 年, 从事 Python 开发 5 年, 为了深入学习操作系统和 Python 语言本身, 如今又重新开始学习 C 语言.<br>带着 Python 语言的学习和实践经验, 我发现 C 语言其实也并没有当年印象中的那么令人难以理解, 让我不禁想要大呼: 学校误我!(bushi)</p><p>想想当年, 非计算机专业, 在对编程语言、操作系统完全没有概念的情况下, 被课程安排牵着做完了所有 C 语言课程的实验, 同时交错着进行汇编实验, 脑子里的问号越来越多, 感觉都来不及思考, 终于 OOM 了.<br>一开始兴致勃勃, 最终心态崩溃、选择放弃. 当然这是对于我这个学渣来说. 想必学霸、学神们早早地就融会贯通了. 我也不得不感叹, 人和人之间的差距实在是太大了.</p><p>现在用自己的方法重新开始学习 C 语言, 希望可以不再像当年那样一头雾水, 也希望能帮助到那些正经历着我当年那种疑惑的同学.</p><p>那么在正式开始学习语法之前, 有必要预先对 C 语言有一个宏观的认识, 可以从纵向和横向两个角度来了解:</p><p>纵向 —— 了解 C 语言的诞生和发展;<br>横向 —— 对比当下与 C 语言并存的其他常见语言, 认识 C 在其中的位置与特点;</p><p>&lt;/br&gt;</p><h2 id="一、C-语言的历史与发展"><a href="#一、C-语言的历史与发展" class="headerlink" title="一、C 语言的历史与发展"></a>一、C 语言的历史与发展</h2><h3 id="一-C-语言的诞生"><a href="#一-C-语言的诞生" class="headerlink" title="(一) C 语言的诞生"></a>(一) C 语言的诞生</h3><p>C 语言最初被创造出来, 主要是为了用于 Unix 系统的开发.</p><p>最初的 Unix 系统运行在 PDP-7 小型计算机上, 是由 Dennis Ritchie 和 Ken Thompson 使用汇编语言(Assembly Language) 开发的.<br>他们希望将 Unix 系统移植到后来的 PDP-11 小型计算机上, 并且最初的 PDP-11 版本 Unix 仍然是使用汇编语言开发的.</p><p>但是 Ken Thompson 希望有一种编程语言可以用来为这个新平台开发工具. </p><p>最初, 他尝试编写一个 Fortran 语言的编译器, 但是很快就放弃了这个想法. 取而代之的是, 他创造了一个精简版本的(cut-down version) BCPL 系统编程语言, 将其称之为 <strong>B 语言</strong>.</p><p>就像 BCPL 一样, B 语言有一个自举(bootstraping)的编译器, 可以使其更方便地移植到新平台.</p><p>然而, 最终只有很少的工具使用 B 语言实现. 因为它(的运行速度)太慢了, 并且不能很好的利用 PDP-11 的特性.</p><p>1971 年, Dennis Ritchie 开始优化 B 语言以便充分利用 PDP-11 相较之前机型更强的性能. 一个典型的新增功能就是字符类型(character type). 他将改进后的语言称为”New B”(NB).</p><p>Thompson 开始使用 NB 编写 Unix 内核, 他的需求也为这项语言的发展指明了方向.</p><p>一直到 1972 年, 这期间, 更多的类型被添加到 NB 语言当中, 比如 <code>int</code> 和 <code>char</code> 数组、指针、所有这些类型的数组等等. </p><p>后来编译器被重新编写, 这种语言被重新命名为 “C”.</p><p>C 语言的编译器以及一些使用 C 语言开发的工具被包含进了第二个版本的 Unix 系统.</p><p>在 1973 年 11 月 发布的 Unix 第四个版本, 内核已经广泛使用了 C 重新实现. 此时的 C 已经获得了像 <code>struct</code> 结构体类型这样的强大特性.</p><p>概括来说, 在 C 语言的诞生过程中, 经历了 BCPL -&gt; B -&gt; NB -&gt; C 这样几个阶段.</p><p>&lt;/br&gt;</p><h3 id="二-C-语言标准-standard-的发展"><a href="#二-C-语言标准-standard-的发展" class="headerlink" title="(二) C 语言标准(standard)的发展"></a>(二) C 语言标准(standard)的发展</h3><h4 id="K-amp-R-C"><a href="#K-amp-R-C" class="headerlink" title="K&amp;R C"></a>K&amp;R C</h4><p>1978 年, Brian Kernighan 和 Dennis Ritchie 出版了第一版的《The C Programming Language》, 这本书后来被 C 开发者称为 “K&amp;R”.</p><p>此时的 C 语言还没有被权威机构进行标准化. 这时的 C 语言又被称作 “K&amp;R C”, 由于是 1978 年发布的, 又被称作 “C78”.</p><p>&lt;/br&gt;</p><h4 id="ANSI-C-和-ISO-C"><a href="#ANSI-C-和-ISO-C" class="headerlink" title="ANSI C 和 ISO C"></a>ANSI C 和 ISO C</h4><p>随着 C 越来越受欢迎, 在十九世纪七八十年代期间, C 语言出现了用于大型机、小型机和微型机的多种不同实现, 包括 IBM 的 PC 机.</p><p>1983 年, 美国国家标准协会(American National Standards Institute, ANSI)成立了委员会, 用来建立 C 语言的标准规范.</p><p>最终在 1989 年, C 语言标准被批准, 这个版本的 C 语言通常被称为 “ANSI C”、”Standard C” 或者 “C89”.</p><p>1990 年, ANSI C 的标准被国际标准化组织(International Organization for Standardization, ISO)采纳, 有时也被称为”C90”.</p><p>所以 “ANSI C”、”C89” 和 “C90” 指的都是同一版本的 C 语言.</p><p>&lt;/br&gt;</p><h4 id="后续版本的-C-语言标准"><a href="#后续版本的-C-语言标准" class="headerlink" title="后续版本的 C 语言标准"></a>后续版本的 C 语言标准</h4><p>随着之后 C 语言标准又被多次修订, 后续的版本又有:</p><ul><li><strong>C99</strong> (1999 年发布)</li><li><strong>C11</strong> (2011 年 12 月 08 日发布)</li><li><strong>C17</strong> (2018 年 06 月发布, 又称 C18, C17 是非正式的名称)</li><li><em>C2x</em> (预计在 2023 年表决, 届时会被称为 C23)</li></ul><p>另外, 由于历史原因, 嵌入式系统 C 编程为了支持各种特殊的特性, 需要非标准化的扩展. </p><p>2008 年, C 标准委员会针对 “<strong>Embedded C</strong>“ 发布了技术报告, 为这些实现提供了一个共用的标准.</p><blockquote><p><a href="https://en.wikipedia.org/wiki/C_(programming_language">Wikipedia - C(Programming Language)</a>)</p></blockquote><p>&lt;/br&gt;</p><h2 id="二、编程语言的意义"><a href="#二、编程语言的意义" class="headerlink" title="二、编程语言的意义"></a>二、编程语言的意义</h2><h3 id="一-编程语言与操作系统的关系"><a href="#一-编程语言与操作系统的关系" class="headerlink" title="(一) 编程语言与操作系统的关系"></a>(一) 编程语言与操作系统的关系</h3><p>参考 <a href="https://en.wikipedia.org/wiki/Operating_system">Wikipedia - Operating System</a> 的定义和图示:</p><p><img src="Operating_system_placement.png" alt=""></p><p>操作系统为用户提供了管理和控制硬件以及应用软件的功能.</p><p>常见的编程语言例如 Python、Java、Golang、JavaScript 都是工作在 Application 应用软件这一层. 通过操作系统提供的 API —— C Library 的函数以及 System Call 系统调用 —— 实现和操作系统的交流和对其的控制.</p><p>而相比之下 C 有些特殊, 因为如 Linux 系统本身就是由 C 编写的, C 即可以用于操作系统层的开发工作, 又可以用于应用软件层的开发工作.</p><p>由于操作系统提供的系统调用 API 是一个有限的集合, 因此不论何种编程语言, 底层的基础可用功能都是有限的, 只是在语言本身的 Runtime 或解释器层面实现了各种不同的高级特性.</p><p>如果能对操作系统的 API 有一个系统性的认识, 那么学习不同编程语言时的陌生感也就弱了很多, 对语言特性的学习也就更加容易了. </p><blockquote><p>笔者是通过 <strong>《The Linux Programming Interface》</strong> 这本书建立起对操作系统 API 的系统性认识的, 推荐给各位有兴趣的同学<br>如果各位同学、大佬有其他推荐, 也希望可以推荐给笔者进行进一步地学习</p></blockquote><p>&lt;/br&gt;</p><h3 id="二-C-语言和其他编程语言的关系"><a href="#二-C-语言和其他编程语言的关系" class="headerlink" title="(二) C 语言和其他编程语言的关系"></a>(二) C 语言和其他编程语言的关系</h3><h4 id="类型系统与内存管理方式对比"><a href="#类型系统与内存管理方式对比" class="headerlink" title="类型系统与内存管理方式对比"></a>类型系统与内存管理方式对比</h4><div class="table-container"><table><thead><tr><th><a href="https://en.wikipedia.org/wiki/C_(programming_language">C</a>)</th><th><a href="https://en.wikipedia.org/wiki/Go_(programming_language">Golang</a>)</th><th><a href="https://en.wikipedia.org/wiki/Java_(programming_language">Java</a>)</th><th><a href="https://en.wikipedia.org/wiki/Python_(programming_language">Python</a>)</th><th><a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a></th></tr></thead><tbody><tr><td>编译型</td><td>编译型</td><td>编译型</td><td>解释型</td><td>解释型</td></tr><tr><td>静态</td><td>静态</td><td>静态</td><td>动态</td><td>动态</td></tr><tr><td>弱类型</td><td>强类型</td><td>强类型</td><td>强类型</td><td>弱类型</td></tr><tr><td>手动分配内存</td><td>自动 GC</td><td>自动 GC</td><td>自动 GC</td><td>自动 GC</td></tr></tbody></table></div><blockquote><p>关于编程语言类型系统的相关概念, 可以通过 <a href="https://en.wikipedia.org/wiki/Type_system">wikipedia - Type System</a> 进行初步了解</p></blockquote><p>大部分的现代编程语言都提供了各种自动机制, 可以使用户在开发过程中不再过分关注内存的分配, 比如动态数组、自动垃圾回收等等.<br>这降低了开发的门槛, 让开发人员能更容易的写出可以正确运行的代码.</p><p>以同是编译型语言的 Golang 和 Java 的垃圾回收机制为例, 自动 GC 减轻了开发者对于内存控制的心智负担, 但是随之而来的是 GC 开销问题, 以及各种针对 GC 的开发技巧和优化方法. 比如主打性能牌的 Golang, 在开发过程中需要关注内存逃逸问题, 而 Java 关注的 GC 优化问题. </p><p>C 语言手动管理内存的方式, 一方面确实会给用户带来开发负担, 但另一方面, 对于性能却是有积极作用的.</p><p>并且, 如果希望深入理解其他语言的垃圾回收机制和内存管理机制等等, C 语言手动管理内存的方式仍然是有必要进行学习的.</p><p>就像 《Effective C》中对 C 语言主旨的描述:</p><ul><li>相信开发者. 通常来说, C 语言会假定你知道自己在做什么, 并且允许你去做. 当然这并不完全是一件好事(比如, 当你不知道你在做什么的时候).</li><li>当开发者需要去做什么的时候, C 语言不会阻止你去做. 因为 C 语言是一项系统编程语言, 它可以用来处理各种贴近底层的工作.</li><li>保持语言小而简. C 语言被设计得足够接近硬件.</li><li>只提供一种方式来实现一个操作. 这也被认为是一种保护机制.</li><li>运行速度快, 即使无法保证可移植性. 允许你实现最佳性能的代码是优先级最高的事.而可移植性和安全性, 也完全委托于你, 开发者.</li></ul><p>可以见得, C 语言赋予开发者最高的自由度. 同时, 开发者也要自己承担安全性、可移植性等设计上的责任.</p><p>这也是 C 语言的魅力所在.</p><p>&lt;/br&gt;</p><h4 id="语法和语言实现的关联"><a href="#语法和语言实现的关联" class="headerlink" title="语法和语言实现的关联"></a>语法和语言实现的关联</h4><p>很多现代编程语言, 都直接或间接地受到 C 语言的影响. 比如类型系统的设计、数据模型, 以及语法等等.</p><p>除了设计上的影响, 还有语言本身实现上的影响, 比如 Python 语言主要版本 Cpython 的解释器, 就是使用 C 语言编写的, Java 语言的 JVM 也是使用 C 语言编写的, Golang 的编译器在实现自举之前, 也是使用 C 实现的. 并且 Python 支持 C Extension 的模式, 可以使用 C 语言扩展 Python 程序的功能. Golang 也可以通过 CGO 实现 C 语言函数的调用.</p><p>&lt;/br&gt;</p><h2 id="三、C-语言的应用"><a href="#三、C-语言的应用" class="headerlink" title="三、C 语言的应用"></a>三、C 语言的应用</h2><p>C 语言目前主要的应用领域有:</p><ul><li>系统开发</li><li>嵌入式开发</li></ul><p>另外, 由于 C 优异的性能, 其他语言的编译器、库、解释器常常使用 C 实现. 比如上文已经提到过的 Cpython 解释器、曾经的 Golang 编译器、Java 的 JVM 等等.</p><p><br/></p><h2 id="四、书目推荐"><a href="#四、书目推荐" class="headerlink" title="四、书目推荐"></a>四、书目推荐</h2><p>在几年的工作和学习生涯中, 我有幸读到了一本书, 是朋友推荐给我的. 可以说是相见恨晚, 如果我能在大学期间读到这本书, 对我的帮助一定是巨大的.</p><p>虽然是在毕业后学习 Python 时才第一次读到这本书, 但它给我的帮助仍然是不可忽视的.</p><p><img src="code.jpg" alt="《编码:隐匿在计算机软硬件背后的语言》"></p><p>另外, 后续的学习会主要围绕 《Effective C》 和 《Modern C》两本书进行.</p><p>《Modern C》的内容主要围绕 C17 标准.<br>《Effective C》书中没有明确说明使用某个单一版本的标准, 但 <a href="https://www.amazon.com/Effective-Introduction-Professional-Robert-Seacord/dp/1718501048">Amazon 商品页</a> 的介绍中描述是覆盖到 C17 标准以及有可能的 C2x 特性 (covering the modern C17 Standard as well as potential C2x features).<br>《The C Programming Language - 2nd Edition》(ANSI C) 内容虽然没有那么新, 但仍然是学习 C 语言基础很好的入门书籍. 推荐优先阅读.</p><p>围绕书本学习的同时, 也会同步用 C 完成 LeetCode 算法题, 用来进行数据类型和语言基础的练习.</p>]]></content>
      
      
      <categories>
          
          <category> C 语言学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彩色月亮</title>
      <link href="/2022/03/20/astro-photography/the-colorful-moon/"/>
      <url>/2022/03/20/astro-photography/the-colorful-moon/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><p><img src="the-colorful-moon.jpeg" alt=""></p><p>设备: Explore Scientific 152/1900 mm 马卡 + EXOS-2 Goto 赤道仪<br>相机: 尼康 D700<br>时间: 2022-03-20 凌晨<br>地点: 阳台</p>]]></content>
      
      
      <categories>
          
          <category> 天文摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天文摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy 中的 from_crawler() 方法应该怎么用?</title>
      <link href="/2021/10/25/python/how-to-use-the-from-crawler-method-in-scrapy/"/>
      <url>/2021/10/25/python/how-to-use-the-from-crawler-method-in-scrapy/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p><code>Crawler</code> 类是 Scrapy 中的一个核心组件, 很多其他组件通过实现 <code>from_crawler()</code> 方法与 <code>Crawler</code> 类建立起联系.<br><code>from_crawler()</code> 方法为爬虫各组件提供了强大的功能扩展支持.<br>本文将结合源码，对<code>from_crawler()</code>方法进行梳理总结.</p><p>全文主要围绕以下几个问题:</p><ol><li>哪些组件可以使用 <code>from_crawler()</code> 方法?</li><li>在 <code>from_crawler()</code>  中都可以实现哪些功能?</li><li><code>from_crawler()</code> 方法是怎么被调用的?</li></ol><p><br/></p><h2 id="一、哪些组件可以使用-from-crawler-方法"><a href="#一、哪些组件可以使用-from-crawler-方法" class="headerlink" title="一、哪些组件可以使用 from_crawler() 方法"></a>一、哪些组件可以使用 <code>from_crawler()</code> 方法</h2><p>首先，常用的组件有：</p><ul><li><code>DupeFilter</code></li><li><code>Scheduler</code></li><li><code>Middlewares</code></li><li><code>Pipelines</code></li><li><code>Extensions</code></li><li><code>Spider</code></li></ul><p>根据场景，不常用的组件有：</p><ul><li><code>downloader.handlers</code></li><li><code>queues</code></li><li><code>dns resolver</code></li><li><code>log formatter</code></li></ul><p>常用组件其实可以参考 <code>scrapy_redis</code> 的实现，很容易就可以看到相关的用法.</p><p>或者可以参考 scrapy 本身模块的实现，项目中可参考的模块有：</p><ul><li><code>scrapy.dupefilter</code></li><li><code>scrapy.core.scheduler</code></li><li><code>scrapy.downloadermiddlewares</code></li><li><code>scrapy.spidermiddlewares</code></li><li><code>scrapy.core.downloader.handlers</code></li><li><code>scrapy.squeues</code></li><li><code>scrapy.resolver</code></li></ul><p><br/></p><h2 id="二、在-from-crawler-方法中都可以实现哪些功能"><a href="#二、在-from-crawler-方法中都可以实现哪些功能" class="headerlink" title="二、在 from_crawler() 方法中都可以实现哪些功能"></a>二、在 <code>from_crawler()</code> 方法中都可以实现哪些功能</h2><p>首先，<code>from_crawler()</code> 最核心的一个目的，是<strong>创建并返回其所在类的实例</strong>。</p><p>比如自己实现 Spider 时，所继承的父类 <code>scrapy.Spider</code>中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>(<span class="params">object_ref</span>):</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 创建所在类的实例并返回</span></span><br><span class="line">        spider = cls(*args, **kwargs)</span><br><span class="line">        spider._set_crawler(crawler)</span><br><span class="line">        <span class="keyword">return</span> spider</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>这里有个相关的知识点：类方法</p></blockquote><p>其次，由于必须传入<code>crawler</code> 实例作为参数，那么我们可以<strong>对 <code>crawler</code> 携带的属性加以利用</strong>。  </p><p>比如内置的爬虫中间件 <code>scrapy.spidermiddlewares.depth.DepthMiddleware</code>：</p><p><em>在 <code>from_crawler()</code> 中获取 settings 中的配置项，将其作为实例属性绑定到中间件实例中</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepthMiddleware</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, maxdepth, stats, verbose_stats=<span class="literal">False</span>, prio=<span class="number">1</span></span>):</span></span><br><span class="line">        self.maxdepth = maxdepth</span><br><span class="line">        self.stats = stats</span><br><span class="line">        self.verbose_stats = verbose_stats</span><br><span class="line">        self.prio = prio</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">        <span class="comment"># 可以获取 crawler.settings 中的配置项，在实例化时作为参数传入</span></span><br><span class="line">        settings = crawler.settings</span><br><span class="line">        maxdepth = settings.getint(<span class="string">&#x27;DEPTH_LIMIT&#x27;</span>)</span><br><span class="line">        verbose = settings.getbool(<span class="string">&#x27;DEPTH_STATS_VERBOSE&#x27;</span>)</span><br><span class="line">        prio = settings.getint(<span class="string">&#x27;DEPTH_PRIORITY&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(maxdepth, crawler.stats, verbose, prio)</span><br><span class="line">      </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>另外，由于 scrapy 提供了信号的支持, 并且 <code>Crawler</code> 实例中绑定了一个 <code>signals</code> 属性。那么，我们可以 <strong>利用信号机制在特定时机执行特定的操作</strong>。</p><p>比如 <a href="https://docs.scrapy.org/en/latest/topics/signals.html">Scrapy 文档 - Signals</a> 一节给出的爬虫示例:</p><p><em><code>from_crawler()</code> 定义了在爬虫结束时，执行 <code>spider_closed（）</code>方法，输出日志</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span>(<span class="params">Spider</span>):</span></span><br><span class="line">    name = <span class="string">&quot;dmoz&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;dmoz.org&quot;</span>]</span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">&quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler, *args, **kwargs</span>):</span></span><br><span class="line">        spider = <span class="built_in">super</span>(DmozSpider, cls).from_crawler(crawler, *args, **kwargs)</span><br><span class="line">        <span class="comment"># 绑定 spider_closed 方法到信号 signals.spider_closed</span></span><br><span class="line">        <span class="comment"># 使其爬虫结束时触发执行</span></span><br><span class="line">        crawler.signals.connect(spider.spider_closed, signal=signals.spider_closed)</span><br><span class="line">        <span class="keyword">return</span> spider</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_closed</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        spider.logger.info(<span class="string">&#x27;Spider closed: %s&#x27;</span>, spider.name)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><em>更多 <code>Crawler</code> 的 API 见文档 <a href="https://docs.scrapy.org/en/latest/topics/api.html#crawler-api">Crawler API</a></em></p><h2 id="三、from-crawler-方法是怎样被调用的"><a href="#三、from-crawler-方法是怎样被调用的" class="headerlink" title="三、from_crawler() 方法是怎样被调用的"></a>三、<code>from_crawler()</code> 方法是怎样被调用的</h2><p>在上述示例中，直接在类里面声明了 <code>from_crawler()</code> 方法，它们会直接被 scrapy 内部流程中被调用。</p><p>那么具体调用过程是什么样的呢？</p><p>上面已经说过，类方法 <code>from_crawler()</code> 的主要功能是创建并返回类的实例，那么只要找到这些组件实例化的位置，就能看到 <code>from_crawler()</code> 被调用的过程。</p><p>这些组件被实例化，主要是通过两种方式：</p><ol><li>直接调用 <code>from_crawler()</code> 进行实例化</li><li>通过 <code>scrapy.util.misc.create_instance()</code> 函数进行实例化</li></ol><p>首先说 1. 直接调用 <code>from_crawler()</code> 进行实例化。</p><p>典型的示例如 <code>scrapy.crawler.Crawler</code> 中，对爬虫类 Spider 进行实例化的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line">   ...</span><br><span class="line">  </span><br><span class="line"><span class="meta">   @defer.inlineCallbacks</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawl</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.crawling:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Crawling already taking place&quot;</span>)</span><br><span class="line">        self.crawling = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.spider = self._create_spider(*args, **kwargs)</span><br><span class="line">            self.engine = self._create_engine()</span><br><span class="line">            start_requests = <span class="built_in">iter</span>(self.spider.start_requests())</span><br><span class="line">            <span class="keyword">yield</span> self.engine.open_spider(self.spider, start_requests)</span><br><span class="line">            <span class="keyword">yield</span> defer.maybeDeferred(self.engine.start)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.crawling = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self.engine <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">yield</span> self.engine.close()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_spider</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 这里直接调用了 spidercls 的 from_crawler 方法，获取 spidercls 的实例</span></span><br><span class="line">        <span class="keyword">return</span> self.spidercls.from_crawler(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_engine</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ExecutionEngine(self, <span class="keyword">lambda</span> _: self.stop())</span><br><span class="line">      </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在 scrapy 中用到最多的是第二种，通过<code>create_instance()</code> 函数进行实例化.</p><p>调用的实例如 scheduler 实例化 dupefilter 的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls, crawler</span>):</span></span><br><span class="line">        settings = crawler.settings</span><br><span class="line">        dupefilter_cls = load_object(settings[<span class="string">&#x27;DUPEFILTER_CLASS&#x27;</span>])</span><br><span class="line">        <span class="comment"># 这里使用 create_instance 对 dupefilter_cls 进行实例化</span></span><br><span class="line">        dupefilter = create_instance(dupefilter_cls, settings, crawler)</span><br><span class="line">        pqclass = load_object(settings[<span class="string">&#x27;SCHEDULER_PRIORITY_QUEUE&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> pqclass <span class="keyword">is</span> PriorityQueue:</span><br><span class="line">            warnings.warn(<span class="string">&quot;SCHEDULER_PRIORITY_QUEUE=&#x27;queuelib.PriorityQueue&#x27;&quot;</span></span><br><span class="line">                          <span class="string">&quot; is no longer supported because of API changes; &quot;</span></span><br><span class="line">                          <span class="string">&quot;please use &#x27;scrapy.pqueues.ScrapyPriorityQueue&#x27;&quot;</span>,</span><br><span class="line">                          ScrapyDeprecationWarning)</span><br><span class="line">            <span class="keyword">from</span> scrapy.pqueues <span class="keyword">import</span> ScrapyPriorityQueue</span><br><span class="line">            pqclass = ScrapyPriorityQueue</span><br><span class="line"></span><br><span class="line">        dqclass = load_object(settings[<span class="string">&#x27;SCHEDULER_DISK_QUEUE&#x27;</span>])</span><br><span class="line">        mqclass = load_object(settings[<span class="string">&#x27;SCHEDULER_MEMORY_QUEUE&#x27;</span>])</span><br><span class="line">        logunser = settings.getbool(<span class="string">&#x27;SCHEDULER_DEBUG&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(dupefilter, jobdir=job_dir(settings), logunser=logunser,</span><br><span class="line">                   stats=crawler.stats, pqclass=pqclass, dqclass=dqclass,</span><br><span class="line">                   mqclass=mqclass, crawler=crawler)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>那么我们来看下 <code>create_instance</code> 函数内部的实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_instance</span>(<span class="params">objcls, settings, crawler, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct a class instance using its ``from_crawler`` or</span></span><br><span class="line"><span class="string">    ``from_settings`` constructors, if available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    At least one of ``settings`` and ``crawler`` needs to be different from</span></span><br><span class="line"><span class="string">    ``None``. If ``settings `` is ``None``, ``crawler.settings`` will be used.</span></span><br><span class="line"><span class="string">    If ``crawler`` is ``None``, only the ``from_settings`` constructor will be</span></span><br><span class="line"><span class="string">    tried.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ``*args`` and ``**kwargs`` are forwarded to the constructors.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises ``ValueError`` if both ``settings`` and ``crawler`` are ``None``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 2.2</span></span><br><span class="line"><span class="string">       Raises ``TypeError`` if the resulting instance is ``None`` (e.g. if an</span></span><br><span class="line"><span class="string">       extension has not been implemented correctly).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> settings <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> crawler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Specify at least one of settings and crawler.&quot;</span>)</span><br><span class="line">        settings = crawler.settings</span><br><span class="line">    <span class="keyword">if</span> crawler <span class="keyword">and</span> <span class="built_in">hasattr</span>(objcls, <span class="string">&#x27;from_crawler&#x27;</span>):</span><br><span class="line">        instance = objcls.from_crawler(crawler, *args, **kwargs)</span><br><span class="line">        method_name = <span class="string">&#x27;from_crawler&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">hasattr</span>(objcls, <span class="string">&#x27;from_settings&#x27;</span>):</span><br><span class="line">        instance = objcls.from_settings(settings, *args, **kwargs)</span><br><span class="line">        method_name = <span class="string">&#x27;from_settings&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        instance = objcls(*args, **kwargs)</span><br><span class="line">        method_name = <span class="string">&#x27;__new__&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f&quot;<span class="subst">&#123;objcls.__qualname__&#125;</span>.<span class="subst">&#123;method_name&#125;</span> returned None&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure><p>逻辑非常清晰明了，根据条件判断调用类的 <code>from_crawler()</code> 方法 或 <code>from_settings()</code> 方法，对类进行实例化，并返回。</p><p>同时，这里也可以看到另一个常见的类方法—— <code>from_settings()</code> ，有着和 <code>from_crawler()</code> 相似的作用。</p><p>但是如果一个组件是通过 <code>create_instance()</code> 被实例化的, 并且组件内又同时实现了 <code>from_crawler()</code> 和 <code>from_settings()</code> 方法，那么将只有 <code>from_crawler()</code> 方法被调用。</p><p>至此, 我们可以对 Scrapy 中常用的 <code>from_crawler()</code> 方法有一个基本的认识.</p><p><br/></p><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><p>[1] <a href="https://docs.scrapy.org/en/latest/index.html">Scrapy documentation</a><br>[2] Scrapy 源码</p>]]></content>
      
      
      <categories>
          
          <category> Scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Virtualbox 创建 VM k8s 集群</title>
      <link href="/2020/09/14/setting-up-a-k8s-cluster-with-vm/"/>
      <url>/2020/09/14/setting-up-a-k8s-cluster-with-vm/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/virtualbox/">Virtualbox</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/centos/7.8.2003/isos/x86_64/">CentOS-7-x86_64-Minimal-2003.iso</a></li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>macOS Catalina</li></ul><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><ol><li>创建 master 虚拟机</li><li>安装 CentOS 系统</li><li>对系统进行必要的设置</li><li>安装 k8s 工作组件</li><li>克隆虚拟机，创建工作节点</li><li>创建集群</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="一-创建-master-虚拟机"><a href="#一-创建-master-虚拟机" class="headerlink" title="(一) 创建 master 虚拟机"></a>(一) 创建 master 虚拟机</h3><ol><li>打开 Virtualbox，点击<strong>新建</strong></li><li><ul><li>名称 <code>k8s-master</code></li><li>类型 <code>Linux</code></li><li>版本 <code>Red Hat(64-bit)</code></li></ul></li><li>使用<strong>建议的内存</strong></li><li>创建虚拟硬盘 <ul><li><code>现在创建虚拟硬盘</code></li><li><code>VDI(Virtualbox磁盘映像)</code></li><li><code>动态分配</code></li><li><code>6.00 GB</code></li></ul></li></ol><p>按照向导提示，选择上面指定的选项，到这里就完成了虚拟机的创建。</p><p>接下来还有一些必要的设置：</p><ol><li>选中虚拟机，点击<em>设置</em></li><li>系统 - 处理器 - 处理器数量 <code>2</code></li><li>网络 - 连接方式 - <code>桥接网卡</code></li></ol><p><em>这里将处理器数量设置为 2，是因为后面在启动 k8s 相关服务的时候，1核 CPU 是无法正常运行的。当然这个值随时可以更改，也可以遇到问题再修改。</em></p><p><em>选择<code>桥接网卡</code>模式，是为了将多个虚拟机组成一个局域网，使每个虚拟机能拥有自己独立的 IP</em></p><p>这样，master 节点的虚拟机就创建好了。</p><h3 id="二-安装-CentOS-7"><a href="#二-安装-CentOS-7" class="headerlink" title="(二) 安装 CentOS 7"></a>(二) 安装 CentOS 7</h3><ol><li>在 Virtualbox 主界面，选中创建好的虚拟机，点击<strong>[光驱]没有盘片</strong>，装载系统镜像</li><li>完成上一步操作后，点击<strong>启动</strong></li><li>启动界面，选择 <code>Install CentOS 7</code></li><li>语言和键盘建议选择 <code>English</code> (避免出现无法输入中文或者中文路径导致异常的情况),<strong>continue</strong> 继续</li><li>到了 Install Summary 的界面，这里要进行的操作比较多<ul><li><strong>DATE &amp; TIME</strong> 修改为<code>Asia/ShangHai</code></li><li><strong>INSTALLATION DESTINATION</strong> 点进去直接 <strong>Done</strong> 再回来</li><li><strong>NETWORK &amp; HOST NAME</strong> 点进去，右侧的开关切换到 <code>ON</code> 的状态，然后下方 <strong>Host name</strong> 修改为 <code>master.k8s</code></li></ul></li><li>完成上一步设置后，可以点击 <strong>Begin Installation</strong> 开始安装</li><li>经过漫长的等待之后，就可以点击 <strong>REBOOT</strong> 重启了，这样系统就安装完成了</li></ol><h3 id="三-必要的系统设置"><a href="#三-必要的系统设置" class="headerlink" title="(三) 必要的系统设置"></a>(三) 必要的系统设置</h3><p>安装k8s相关组件的时候，有以下设置必须完成：</p><ul><li>关闭 SELinux</li><li>关闭 Firewalld</li><li>关闭 Swap</li><li>开启 <code>net.bridge.bridge-nf-call-iptables</code> 内核选项</li></ul><h4 id="1-关闭-SELinux"><a href="#1-关闭-SELinux" class="headerlink" title="1. 关闭 SELinux"></a>1. 关闭 SELinux</h4><p><em>由于 VM 里面还没有安装 Vim，可以选择先安装，或者直接使用 Vi 进行编辑</em></p><p>修改 <strong>/etc/selinux/config</strong>, 将文件中的 <code>SELINUX=enforcing</code> 一行，修改为 <code>SELINUX=permissive</code></p><h4 id="2-关闭-Firewalld"><a href="#2-关闭-Firewalld" class="headerlink" title="2. 关闭 Firewalld"></a>2. 关闭 Firewalld</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">disable</span> firewalld &amp;&amp; systemctl stop firewalld</span><br></pre></td></tr></table></figure><h4 id="3-关闭-Swap"><a href="#3-关闭-Swap" class="headerlink" title="3. 关闭 Swap"></a>3. 关闭 Swap</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swapoff -a &amp;&amp; sed -i <span class="string">&#x27;/ swap / s/^/#/&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure><p>可以使用 <code>free -w</code> 来查看完整的内存信息，可以看到 <code>swap</code> 的状态</p><h4 id="4-开启-net-bridge-bridge-nf-call-iptables-内核设置"><a href="#4-开启-net-bridge-bridge-nf-call-iptables-内核设置" class="headerlink" title="4. 开启 net.bridge.bridge-nf-call-iptables 内核设置"></a>4. 开启 <code>net.bridge.bridge-nf-call-iptables</code> 内核设置</h4><p>这一步在这里还不能执行，需要等到启动 docker 和 kubelet 服务之后，才能正确执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-iptables=1&quot;</span> &gt; /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure><h3 id="四-安装-k8s-工作组件"><a href="#四-安装-k8s-工作组件" class="headerlink" title="(四) 安装 k8s 工作组件"></a>(四) 安装 k8s 工作组件</h3><p>由于无法访问 google 源，并且 k8s 拉取镜像时会默认访问境外的 Docker 镜像仓库，从这里开始会遇到一些坑，需要手动去完成操作。</p><h4 id="1-添加-kubernetes-yum源"><a href="#1-添加-kubernetes-yum源" class="headerlink" title="1. 添加 kubernetes yum源"></a>1. 添加 kubernetes yum源</h4><p>这里选择阿里云的 yum 源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">exclude=kube*</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h4 id="2-安装必要组件"><a href="#2-安装必要组件" class="headerlink" title="2. 安装必要组件"></a>2. 安装必要组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker kubelet kubeadm kubectl kubernetes-cni --disableexcludes&#x3D;kubernetes</span><br></pre></td></tr></table></figure><h4 id="3-启动必要服务"><a href="#3-启动必要服务" class="headerlink" title="3. 启动必要服务"></a>3. 启动必要服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span><br><span class="line">$ systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><p><em>在这里执行 <code>net.bridge.bridge-nf-call-iptables</code> 的相关设置</em></p><h3 id="五-克隆虚拟机，创建工作节点"><a href="#五-克隆虚拟机，创建工作节点" class="headerlink" title="(五) 克隆虚拟机，创建工作节点"></a>(五) 克隆虚拟机，创建工作节点</h3><ol><li>首先 <code>shutdown now</code> 关闭当前 master 虚拟机</li><li>在 Virtualbox 主界面选中 master 虚拟机，右键，选择<code>复制</code><ul><li>名称 <code>m8s-node1</code></li><li>MAC 地址设定 <code>为所有网卡重新生成 MAC 地址</code></li><li>点击<code>继续</code>， 选择<code>完全复制</code></li></ul></li><li>参照步骤 2，克隆 <code>k8s-node2</code></li><li>启动所有节点</li><li>使用 <code>hostnamectl --static set-hostname node1.k8s</code> 修改 node1 的名称(node2同理)，重启就可以看到效果了</li><li>使用 <code>ip addr</code> 命令查看每一台虚拟机的 IP 地址，按照如下格式追加到所有节点的 <code>/etc/hosts</code> 文件中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.104 master.k8s</span><br><span class="line">192.168.0.105 node1.k8s</span><br><span class="line">192.168.0.106 node2.k8s</span><br></pre></td></tr></table></figure><h3 id="六-创建集群"><a href="#六-创建集群" class="headerlink" title="(六) 创建集群"></a>(六) 创建集群</h3><h4 id="1-手动拉取-docker-镜像"><a href="#1-手动拉取-docker-镜像" class="headerlink" title="1. 手动拉取 docker 镜像"></a>1. 手动拉取 docker 镜像</h4><p>原本直接使用 <code>kubeadm init</code> 就可以初始化集群的 master 节点，但是由于 k8s 默认拉取镜像的源被墙，直接运行命令完全没办法继续。</p><p>因此，这里我们参考 <a href="https://zhuanlan.zhihu.com/p/46341911">这篇文章</a> 的方法，使用 shell 脚本的方式手动获取镜像。</p><p>为了稍微少打几行字，我们可以 <code>kubeadm config images list &gt; manualpull.sh</code> 将镜像名称输入到文件。</p><p>然后使用参考文章中给出的脚本手动拉取 docker 镜像。</p><p>脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">images=(</span><br><span class="line">    kube-apiserver:v1.12.1</span><br><span class="line">    kube-controller-manager:v1.12.1</span><br><span class="line">    kube-scheduler:v1.12.1</span><br><span class="line">    kube-proxy:v1.12.1</span><br><span class="line">    pause:3.1</span><br><span class="line">    etcd:3.2.24</span><br><span class="line">    coredns:1.2.2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span> k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><em>这里拉取的 docker 镜像每个节点都需要，因此可以选择先拉取镜像，再克隆节点。也可以通过 <code>scp</code> 发送脚本在各节点中单独拉取。</em></p><h4 id="2-集群-master-节点初始化"><a href="#2-集群-master-节点初始化" class="headerlink" title="2. 集群 master 节点初始化"></a>2. 集群 master 节点初始化</h4><p>执行命令进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init &gt; initialization.log</span><br></pre></td></tr></table></figure><p><em>这里把输出写入文件主要是因为 VM 里面不方便复制粘贴和滚屏，写文件比较容易编辑</em></p><h4 id="3-设置-kubectl-环境变量"><a href="#3-设置-kubectl-环境变量" class="headerlink" title="3. 设置 kubectl 环境变量"></a>3. 设置 <code>kubectl</code> 环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>将上面这行写入 <code>/etc/profile</code> 文件中，然后执行如下命令使修改生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="4-将工作节点加入集群"><a href="#4-将工作节点加入集群" class="headerlink" title="4. 将工作节点加入集群"></a>4. 将工作节点加入集群</h4><p>执行 <code>tail -n 2 &gt; joinode.sh</code> 将 <code>initialization.log</code> 文件末尾两行的命令写入文件，发送到工作节点中。 格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.0.104:6443 --token ezalac.umfjciqd2lumq1yl --discovery-token-ca-cert-hash sha256:b104b5832b0ab52871161dec0156c7f2ee3456ed90900a153377a3155a6baed6</span><br></pre></td></tr></table></figure><p>在 node1, node2 分别执行 <code>bash joinode.sh</code></p><p>然后在 master 节点中，使用命令 <code>kubectl get nodes</code> 就可以查看到新加入的两个子节点了。</p><p>不过这个时候状态还是 <strong>Not Ready</strong>，还需要给 master 节点安装网络插件</p><h4 id="5-为-master-节点安装网络插件"><a href="#5-为-master-节点安装网络插件" class="headerlink" title="5. 为 master 节点安装网络插件"></a>5. 为 master 节点安装网络插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f <span class="string">&quot;https://cloud.weave.works/k8s/net?k8s-version=<span class="subst">$(kubectl version | base64 | tr -d &#x27;\n&#x27;)</span></span></span><br></pre></td></tr></table></figure><h4 id="6-拷贝配置文件"><a href="#6-拷贝配置文件" class="headerlink" title="6. 拷贝配置文件"></a>6. 拷贝配置文件</h4><p>首先将配置文件拷贝到工作节点 node1 和 node2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -P 22 /etc/kubernetes/admin.conf root@192.168.0.104:/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>然后用和上面同样的方式，设置好环境变量。</p><p>以上设置完成之后，可以在 master 节点使用 <code>kubectl get nodes</code> 命令看到，节点都已经变成了 <strong>ready</strong> 的状态，这样，一个虚拟机组成的练手集群就搭建完成了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《Kubernetes in Action》 - Appendix B</li><li><a href="https://zhuanlan.zhihu.com/p/46341911">kubernetes安装（国内环境）- soolaugust[知乎]</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
            <tag> VirtualBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asyncio源码浅析（一）- 事件循环(EventLoop)</title>
      <link href="/2020/07/05/python/asyncio-source-code-analysis/"/>
      <url>/2020/07/05/python/asyncio-source-code-analysis/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一篇笔记会主要从 <code>asyncio</code> 标准库源码的角度，来熟悉 Python 3.7 所提供的异步编程API。同时，尝试着理解和灵活运用 <code>asyncio</code> 所提供的功能。由于涉及到不同平台的实现不同，而我们使用最多的是Linux平台。因此，梳理过程中主要以Linux平台相关实现为主。并且，本篇以理解流程为重点，不会对每一行代码进行分析，相关细节可以在理解流程后再做深入。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>说到 <strong>异步编程</strong> 或者 <code>asyncio</code> ，首先需要对几种I/O模型有些基本的概念。这个在网上已经有了很多的博文，这里就不再赘述。在《Unix网络编程 Vol.1》和《The Linux Programming Interface》中，对I/O模型的特点和相关的系统调用也有详尽的介绍。5类I/O模型如下：</p><ul><li>阻塞I/O（blocking I/O）</li><li>非阻塞I/O（nonblocking I/O）</li><li>I/O多路复用（I/O multiplexing）</li><li>信号驱动I/O（signal driven I/O）</li><li>异步I/O（asynchronous I/O）</li></ul><p>使用<code>asyncio</code> 进行编程，应用的是I/O多路复用模型，即在单个进程（或线程）中，同时监听多个描述符，实现对进程（或线程）的复用。另外，I/O多路复用模型与非阻塞I/O模型并不是互斥的关系，事实上，它正是基于非阻塞I/O才得以实现的。</p><p>通常，我们会更多地在网络编程中用到，而且很多示例都是使用 <code>socket</code> 来介绍的(比如下文的 <code>selectors</code>)，这让我产生了一种错觉：I/O多路复用模型是不是只能应用在网络编程或者socket编程中呢？ 答案是否定的。事实上，通过学习与I/O多路复用相关的系统调用，可以了解到，devices(terminals ans pseudoterminals)、pipes、FIFOs类型，同样支持非阻塞模式。那么自然，I/O多路复用模型也可以用于这些类型的文件描述符监听。</p><h2 id="selectors-简介"><a href="#selectors-简介" class="headerlink" title="selectors 简介"></a><code>selectors</code> 简介</h2><p>在总结 <code>asyncio</code> 之前，有必要先了解一下<code>selectors</code>标准库。<code>selectors</code>是在 Python 3.4 版本加入到Python标准库中，旨在提供高效的、high-level的I/O多路复用支持。它是依赖于更 low-level 的<code>select</code>模块实现的。</p><p><code>selectors</code>中的类层级关系如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseSelector</span><br><span class="line">    +-- SelectSelector</span><br><span class="line">    +-- PollSelector</span><br><span class="line">    +-- EpollSelector</span><br><span class="line">    +-- DevpollSelector</span><br><span class="line">    +-- KqueueSelector</span><br></pre></td></tr></table></figure><p>这其中不同的 “Selector” ，是基于不同平台的实现。当然，<code>selectors</code> 中提供了方便的 <code>DefaultSelector</code> 类，可以根据当前平台自动选择合适的 Selector 类，也是推荐大部分用户直接使用的类。</p><p>下面是官方文档中提供的标准示例，理解这个例子非常有助于进一步理解asyncio的逻辑。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()       <span class="comment"># &lt;1&gt; 示例化Selector，根据平台进行选择</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">sock, mask</span>):</span></span><br><span class="line">    conn, addr = sock.accept()  <span class="comment"># Should be ready  &lt;7&gt; 获得客户端连接的描述符</span></span><br><span class="line">    print(<span class="string">&#x27;accepted&#x27;</span>, conn, <span class="string">&#x27;from&#x27;</span>, addr)</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>)     <span class="comment"># &lt;8&gt; 设置为非阻塞模式</span></span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)      <span class="comment"># &lt;9&gt; 绑定事件和回调函数，将描述符注册到selector上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">conn, mask</span>):</span></span><br><span class="line">    data = conn.recv(<span class="number">1000</span>)  <span class="comment"># Should be ready</span></span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        print(<span class="string">&#x27;echoing&#x27;</span>, <span class="built_in">repr</span>(data), <span class="string">&#x27;to&#x27;</span>, conn)</span><br><span class="line">        conn.send(data)  <span class="comment"># Hope it won&#x27;t block</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;closing&#x27;</span>, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()      <span class="comment"># &lt;2&gt; 获得socket实例</span></span><br><span class="line">sock.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">1234</span>))      <span class="comment"># &lt;3&gt; 服务端，绑定地址，监听链接</span></span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)     <span class="comment"># &lt;4&gt;  设置为非阻塞模式</span></span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)        <span class="comment"># &lt;5&gt; 将socket实例和回调函数，绑定事件，注册到selector中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:             <span class="comment"># &lt;6&gt; 开启事件循环，在每一轮循环中阻塞在select调用处，等待事件触发返回可用描述符</span></span><br><span class="line">    events = sel.select()</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)  <span class="comment"># 调用回调函数</span></span><br></pre></td></tr></table></figure><p>根据这个简单的例子，其中有几个关键的对象和步骤：</p><p><strong>对象：</strong></p><ul><li>文件描述符（file descriptor）-  <code>conn</code> <code>sock</code></li><li>回调函数（callback） - <code>accept()</code> <code>read()</code></li><li>事件循环 (event loop) - <code>while: ...</code></li></ul><p><strong>过程：</strong></p><ul><li>设置非阻塞模式 - <code>fd.setblocking(False)</code></li><li>注册描述符 - <code>sel.register(fd, event, callback)</code></li></ul><p>这是一个最简单的I/O多路复用模式的雏形。在分析 <code>asyncio</code> 源码的过程中，始终记住这个模板，并且尝试的把不同角色对应起来，对理解<code>asyncio</code>复杂的调度会非常有帮助。那么接下来就进入正题。</p><h2 id="asyncio-源码浅析"><a href="#asyncio-源码浅析" class="headerlink" title="asyncio 源码浅析"></a><code>asyncio</code> 源码浅析</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">asyncio</span><br><span class="line">    + —— __init__.py</span><br><span class="line">    + —— base_events.py</span><br><span class="line">    + —— base_futures.py</span><br><span class="line">    + —— base_subprocess.py</span><br><span class="line">    + —— base_tasks.py</span><br><span class="line">    + —— constants.py</span><br><span class="line">    + —— coroutines.py</span><br><span class="line">    + —— events.py</span><br><span class="line">    + —— format_helpers.py</span><br><span class="line">    + —— futures.py</span><br><span class="line">    + —— locks.py</span><br><span class="line">    + —— log.py</span><br><span class="line">    + —— proactor_events.py</span><br><span class="line">    + —— protocols.py</span><br><span class="line">    + —— queues.py</span><br><span class="line">    + —— runners.py</span><br><span class="line">    + —— selector_events.py</span><br><span class="line">    + —— sslproto.py</span><br><span class="line">    + —— streams.py</span><br><span class="line">    + —— subprocess.py</span><br><span class="line">    + —— tasks.py</span><br><span class="line">    + —— transports.py</span><br><span class="line">    + —— unix_events.py</span><br><span class="line">    + —— windows_events.py</span><br><span class="line">    + —— windows_utils.py</span><br></pre></td></tr></table></figure><p>为了快速的了解 <code>asyncio</code> 的基本工作模式，这里选择暂时忽略一些内容，只提取其中涉及到调度的核心部分来进行分析。</p><p>那么，挑挑拣拣，剩下一些主要模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asyncio</span><br><span class="line">    + —— __init__.py</span><br><span class="line">    + —— base_events.py</span><br><span class="line">    + —— base_futures.py</span><br><span class="line">    + —— base_tasks.py</span><br><span class="line">    + —— events.py</span><br><span class="line">    + —— futures.py</span><br><span class="line">    + —— proactor_events.py</span><br><span class="line">    + —— runners.py</span><br><span class="line">    + —— selector_events.py</span><br><span class="line">    + —— tasks.py</span><br><span class="line">    + —— unix_events.py</span><br><span class="line">    + —— windows_events.py</span><br></pre></td></tr></table></figure><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p><strong><code>EventLoop</code></strong></p><p>相关文件: <code>events.py</code>, <code>base_events.py</code>, <code>selector_events.py</code>, <code>windows_events.py</code>, <code>proactor_events.py</code></p><p>由上面 <code>selectors</code> 的示例可以看出，最终的 <code>while</code> 循环是使得整个逻辑运行起来的核心。在<code>asyncio</code> 中，事件循环被抽象为一系列的类，它负责了异步任务、回调函数的执行，进行网络I/O操作和子进程的运行等，是基于<code>asyncio</code>的应用的核心。根据不同平台，有不同的子类实现，继承关系如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AbstractEventLoop</span><br><span class="line">    |</span><br><span class="line">    + —— BaseEventLoop</span><br><span class="line">            |</span><br><span class="line">            + —— BaseSelectorEventLoop</span><br><span class="line">            |        |</span><br><span class="line">            |        + —— _UnixSelectorEventLoop</span><br><span class="line">            |        |</span><br><span class="line">            |        + —— _WindowsSelectorEventLoop</span><br><span class="line">            |</span><br><span class="line">            + —— BaseProactorEventLoop</span><br><span class="line">                     |</span><br><span class="line">                     + —— ProactorEventLoop</span><br></pre></td></tr></table></figure><p>首先，对于我们最常用的 <code>loop.run_until_complete()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span>(<span class="params">events.AbstractEventLoop</span>):</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span>(<span class="params">self, future</span>):</span></span><br><span class="line">        self._check_closed()</span><br><span class="line"></span><br><span class="line">        new_task = <span class="keyword">not</span> futures.isfuture(future)</span><br><span class="line">        future = tasks.ensure_future(future, loop=self)</span><br><span class="line">        <span class="keyword">if</span> new_task:</span><br><span class="line">            future._log_destroy_pending = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        future.add_done_callback(_run_until_complete_cb)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run_forever()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span> new_task <span class="keyword">and</span> future.done() <span class="keyword">and</span> <span class="keyword">not</span> future.cancelled():</span><br><span class="line">                future.exception()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            future.remove_done_callback(_run_until_complete_cb)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> future.done():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Event loop stopped before Future completed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> future.result()</span><br></pre></td></tr></table></figure><p>可以看到，<code>run_until_complete()</code>方法其实是通过 <code>run_forever()</code>方法和 <code>_run_until_complete_cb()</code> 这个回调函数来实现运行完成后终止的。<br>回调函数通过 <code>futurn.add_done_callback()</code> 来进行添加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_until_complete_cb</span>(<span class="params">fut</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fut.cancelled():</span><br><span class="line">        exc = fut.exception()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc, BaseException) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(exc, Exception):</span><br><span class="line">            <span class="comment"># Issue #22429: run_forever() already finished, no need to</span></span><br><span class="line">            <span class="comment"># stop it.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    futures._get_loop(fut).stop()</span><br></pre></td></tr></table></figure><p>这个回调函数，在 <code>fut</code> 执行结束后，最关键的一步，获取到它的事件循环，并调用 <code>stop()</code> 方法将其停止。</p><p><code>run_forever()</code> 的源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_events.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span>(<span class="params">events.AbstractEventLoop</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run until stop() is called.&quot;&quot;&quot;</span></span><br><span class="line">        self._check_closed()</span><br><span class="line">        <span class="keyword">if</span> self.is_running():</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;This event loop is already running&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> events._get_running_loop() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">&#x27;Cannot run the event loop while another loop is running&#x27;</span>)</span><br><span class="line">        self._set_coroutine_origin_tracking(self._debug)</span><br><span class="line">        self._thread_id = threading.get_ident()</span><br><span class="line"></span><br><span class="line">        old_agen_hooks = sys.get_asyncgen_hooks()</span><br><span class="line">        sys.set_asyncgen_hooks(firstiter=self._asyncgen_firstiter_hook,</span><br><span class="line">                               finalizer=self._asyncgen_finalizer_hook)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            events._set_running_loop(self)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                self._run_once()</span><br><span class="line">                <span class="keyword">if</span> self._stopping:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._stopping = <span class="literal">False</span></span><br><span class="line">            self._thread_id = <span class="literal">None</span></span><br><span class="line">            events._set_running_loop(<span class="literal">None</span>)</span><br><span class="line">            self._set_coroutine_origin_tracking(<span class="literal">False</span>)</span><br><span class="line">            sys.set_asyncgen_hooks(*old_agen_hooks)</span><br></pre></td></tr></table></figure></p><p>回想开篇 <code>selectors</code> 的示例，在这里首先对应上了第一个关键结构：事件循环 <code>while ...</code></p><p>显然，如果我们调用 <code>run_forever()</code>方法，事件循环将会永远的运行下去，除非强制中断。在实际的应用中，我们就不能像使用 <code>run_until_complete()</code> 时，还将一部分代码功能留在“外部”，我们应该预先定义基于任务与回调的代码逻辑，让事件循环来完成调用执行工作，在运行代码的最后一步，调用<code>run_forever()</code>启动事件循环，使程序持续运转起来。</p><p>在这个核心的循环中，可以看到，当 <code>_stopping</code> 被设置成 <code>False</code> 时，循环立即退出；否则，每一轮循环，调用一次 <code>_run_once()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    self._run_once()</span><br><span class="line">    <span class="keyword">if</span> self._stopping:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>接下来进入到 <code>_run_once()</code> 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEventLoop</span>(<span class="params">events.AbstractEventLoop</span>):</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_once</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run one full iteration of the event loop.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This calls all currently ready callbacks, polls for I/O,</span></span><br><span class="line"><span class="string">        schedules the resulting callbacks, and finally schedules</span></span><br><span class="line"><span class="string">        &#x27;call_later&#x27; callbacks.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        sched_count = <span class="built_in">len</span>(self._scheduled)</span><br><span class="line">        <span class="keyword">if</span> (sched_count &gt; _MIN_SCHEDULED_TIMER_HANDLES <span class="keyword">and</span></span><br><span class="line">            self._timer_cancelled_count / sched_count &gt;</span><br><span class="line">                _MIN_CANCELLED_TIMER_HANDLES_FRACTION):</span><br><span class="line">            <span class="comment"># Remove delayed calls that were cancelled if their number</span></span><br><span class="line">            <span class="comment"># is too high</span></span><br><span class="line">            new_scheduled = []</span><br><span class="line">            <span class="keyword">for</span> handle <span class="keyword">in</span> self._scheduled:</span><br><span class="line">                <span class="keyword">if</span> handle._cancelled:</span><br><span class="line">                    handle._scheduled = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_scheduled.append(handle)</span><br><span class="line"></span><br><span class="line">            heapq.heapify(new_scheduled)</span><br><span class="line">            self._scheduled = new_scheduled</span><br><span class="line">            self._timer_cancelled_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Remove delayed calls that were cancelled from head of queue.</span></span><br><span class="line">            <span class="keyword">while</span> self._scheduled <span class="keyword">and</span> self._scheduled[<span class="number">0</span>]._cancelled:</span><br><span class="line">                self._timer_cancelled_count -= <span class="number">1</span></span><br><span class="line">                handle = heapq.heappop(self._scheduled)</span><br><span class="line">                handle._scheduled = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        timeout = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self._ready <span class="keyword">or</span> self._stopping:</span><br><span class="line">            timeout = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> self._scheduled:</span><br><span class="line">            <span class="comment"># Compute the desired timeout.</span></span><br><span class="line">            when = self._scheduled[<span class="number">0</span>]._when</span><br><span class="line">            timeout = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">0</span>, when - self.time()), MAXIMUM_SELECT_TIMEOUT)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._debug <span class="keyword">and</span> timeout != <span class="number">0</span>:</span><br><span class="line">            t0 = self.time()</span><br><span class="line">            event_list = self._selector.select(timeout)</span><br><span class="line">            dt = self.time() - t0</span><br><span class="line">            <span class="keyword">if</span> dt &gt;= <span class="number">1.0</span>:</span><br><span class="line">                level = logging.INFO</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                level = logging.DEBUG</span><br><span class="line">            nevent = <span class="built_in">len</span>(event_list)</span><br><span class="line">            <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                logger.log(level, <span class="string">&#x27;poll took %.3f ms: %s events&#x27;</span>,</span><br><span class="line">                           dt * <span class="number">1e3</span>, nevent)</span><br><span class="line">            <span class="keyword">elif</span> nevent:</span><br><span class="line">                logger.log(level,</span><br><span class="line">                           <span class="string">&#x27;poll %.3f ms took %.3f ms: %s events&#x27;</span>,</span><br><span class="line">                           timeout * <span class="number">1e3</span>, dt * <span class="number">1e3</span>, nevent)</span><br><span class="line">            <span class="keyword">elif</span> dt &gt;= <span class="number">1.0</span>:</span><br><span class="line">                logger.log(level,</span><br><span class="line">                           <span class="string">&#x27;poll %.3f ms took %.3f ms: timeout&#x27;</span>,</span><br><span class="line">                           timeout * <span class="number">1e3</span>, dt * <span class="number">1e3</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event_list = self._selector.select(timeout)</span><br><span class="line">        self._process_events(event_list)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Handle &#x27;later&#x27; callbacks that are ready.</span></span><br><span class="line">        end_time = self.time() + self._clock_resolution</span><br><span class="line">        <span class="keyword">while</span> self._scheduled:</span><br><span class="line">            handle = self._scheduled[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> handle._when &gt;= end_time:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            handle = heapq.heappop(self._scheduled)</span><br><span class="line">            handle._scheduled = <span class="literal">False</span></span><br><span class="line">            self._ready.append(handle)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This is the only place where callbacks are actually *called*.</span></span><br><span class="line">        <span class="comment"># All other places just add them to ready.</span></span><br><span class="line">        <span class="comment"># Note: We run all currently scheduled callbacks, but not any</span></span><br><span class="line">        <span class="comment"># callbacks scheduled by callbacks run this time around --</span></span><br><span class="line">        <span class="comment"># they will be run the next time (after another I/O poll).</span></span><br><span class="line">        <span class="comment"># Use an idiom that is thread-safe without using locks.</span></span><br><span class="line">        ntodo = <span class="built_in">len</span>(self._ready)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ntodo):</span><br><span class="line">            handle = self._ready.popleft()</span><br><span class="line">            <span class="keyword">if</span> handle._cancelled:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self._debug:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self._current_handle = handle</span><br><span class="line">                    t0 = self.time()</span><br><span class="line">                    handle._run()</span><br><span class="line">                    dt = self.time() - t0</span><br><span class="line">                    <span class="keyword">if</span> dt &gt;= self.slow_callback_duration:</span><br><span class="line">                        logger.warning(<span class="string">&#x27;Executing %s took %.3f seconds&#x27;</span>,</span><br><span class="line">                                       _format_handle(handle), dt)</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    self._current_handle = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                handle._run()</span><br><span class="line">        handle = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>从上到下看了一遍，有几个问题需要继续思考一下：</p><ol><li>前面都没有遇到 <code>self._scheduled</code>, 为什么这里看上去需要 <code>self._scheduled</code> 里面有值才行？ <code>self_scheduled</code> 到底是在什么位置被添加进了值呢？</li><li><code>self._selector.select(timeout)</code> 在这里直接等待事件触发返回描述符，并且后续调用 <code>self._process_events(event_list)</code> 处理获取到的描述符。那么，这些描述符，不论是Socket描述符，还是其他类型的描述符，又是在什么地方被注册到 <code>self._selector</code> 中的呢？</li></ol><p>下一篇笔记，我们从一个实例出发，开始寻找这两个问题的答案。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asyncio </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程实现模型(Thread Implementation models)</title>
      <link href="/2020/03/20/linux/thread-implementation-models/"/>
      <url>/2020/03/20/linux/thread-implementation-models/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前，我总结了一篇<a href="/2019/02/13/user-level-threads-and-kernel-level-threads/">用户级线程 与 内核级线程</a>的问答，描述了<strong>用户级线程</strong>和<strong>内核级线程</strong>各自的特性。这也使我一度认为，Python中常常被人诟病的多线程无法同时被多核分配的原因，是因为它使用了用户级线程。然而最近，在我重新审视一些多线程的问题时，我突然发现，我的理解存在很大偏差。于是我重新查阅了一些资料，在这里重新进行梳理。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="POSIX-Threads"><a href="#POSIX-Threads" class="headerlink" title="POSIX Threads"></a>POSIX Threads</h3><p>为了保证多线程编程的可移植性，IEEE定义了一套标准的线程接口规范，这就是POSIX线程规范。跟据这个规范实现的线程库，通常被称作Pthread。POSIX Threads只是接口规范的定义，具体的实现取决于不同的操作系统。</p><h3 id="KSE-Kernel-Scheduling-Entity"><a href="#KSE-Kernel-Scheduling-Entity" class="headerlink" title="KSE(Kernel Scheduling Entity)"></a>KSE(Kernel Scheduling Entity)</h3><p>内核调度实体是最终内核进行调度的对象，可以将线程或者进程看作是基于KSE构建的抽象调度单元，仅仅是在共享的一些属性上有些或多或少的差异(虚拟内存、文件描述符、PID等等)。Posix Threads对线程间属性共享的要求，只是众多可能性中的一种。</p><h2 id="线程实现模型（Thread-Implementation-models）"><a href="#线程实现模型（Thread-Implementation-models）" class="headerlink" title="线程实现模型（Thread Implementation models）"></a>线程实现模型（Thread Implementation models）</h2><p>不同线程实现模型间的主要区别在于线程与KSEs的映射关系。</p><h3 id="多对一实现-Many-to-one-M-1-Implementations"><a href="#多对一实现-Many-to-one-M-1-Implementations" class="headerlink" title="多对一实现(Many-to-one M:1 Implementations)"></a>多对一实现(Many-to-one M:1 Implementations)</h3><p>多对一实现，又被称作<strong>用户级线程</strong>(user-level threads)。<br>在多对一实现中，线程的创建、调度和同步完全由用户空间的线程库来处理，内核对多个线程的存在并无感知。那么，这样的实现就存在两个问题：</p><ul><li><p>当一个线程发起系统调用，比如<code>read()</code>，控制权由用户空间的线程库转交到了内核，那么所有线程都将被阻塞</p></li><li><p>由于内核感知不到用户空间多个线程的存在，内核无法参与调度，线程也就无法被多核分配。</p></li></ul><p><em>第二点听起来很像Python多线程的情况，但实际并不是这样，这也是我最开始理解错的地方。线程实现取决于操作系统，Linux中的线程是使用1:1模型实现的，而Python多线程同一时刻只有一个线程运行，是因为Python解释器存在线程安全问题，引入了GIL，从而限制了多个线程的调度运行</em></p><h3 id="一对一实现-One-to-one-1-1-Implementations"><a href="#一对一实现-One-to-one-1-1-Implementations" class="headerlink" title="一对一实现(One-to-one 1:1 Implementations)"></a>一对一实现(One-to-one 1:1 Implementations)</h3><p>一对一实现，又被称作<strong>内核级线程</strong>(kernel-level threads)。<br>在一对一实现中，每个线程对应一个独立的KSE。内核可以独立调度每一个线程，线程间同步是通过系统调用实现的。<br>1:1实现解决了一个M:1中的问题。一个阻塞的系统调用不会导致进程中所有线程都被阻塞。然而，内核需要为每一个线程维护一个KSE，如果开启了大量的线程，会增加内核调度的负荷，影响系统性能。</p><p>尽管存在着一些缺点，但1:1模型仍然是比较好的选择。Linux系统的两种线程实现 —— LinuxThreads 和 NPTL(Native Posix Threads Library) 都是使用的1:1实现模型。</p><h3 id="多对一实现-Many-to-many-M-N-Implementations"><a href="#多对一实现-Many-to-many-M-N-Implementations" class="headerlink" title="多对一实现(Many-to-many M:N Implementations)"></a>多对一实现(Many-to-many M:N Implementations)</h3><p>多对多实现，又被称作<strong>两级线程</strong>(two-level threads)。<br>两级线程实现解决了M:1和1:1实现模型的缺点，然而它也存在一个重要的问题，就是它两级实现过于复杂(complexity)了。<br>起初NPTL考虑过M:N实现，但是由于需要对内核进行修改，而且可能并没有足够的必要性，最终被驳回了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，线程实现取决于操作系统，Linux选用的是1:1实现模型，即内核级线程。<br>而Python在Linux平台上同样使用的是Linux pthread，然而由于GIL，导致了线程被限制，无法同时被多核调度。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>The Linux Programming Interface 28.2.1/33.4</li><li><a href="http://man7.org/linux/man-pages/man7/pthreads.7.html">Linux Man Pages - pthread</a></li><li>现代操作系统</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统调用(System Calls)流程</title>
      <link href="/2019/12/04/linux/system-calls/"/>
      <url>/2019/12/04/linux/system-calls/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系统调用（System Calls）是受约束的内核入口，允许进程控制内核来完成指定的操作。内核提供了一系列的系统调用API（Application Programming Interface）来完成相关的功能，例如创建进程、执行I/O操作、创建用于进程间通信的管道等。</p><p>关于系统调用，这里需要掌握三点基本常识：</p><ul><li><p>系统调用会将处理器的状态由<strong>用户态</strong>（User Mode）转变为<strong>内核态</strong>（Kernel Mode）</p></li><li><p>系统调用的集合是固定的，每一个系统调用由一个唯一的数字标识（这个数字通常对程序是不可见的）</p></li><li><p>系统调用可能包含一系列的参数，用于指定哪些信息需要从用户空间传递到内核空间</p></li></ul><h2 id="系统调用过程分解"><a href="#系统调用过程分解" class="headerlink" title="系统调用过程分解"></a>系统调用过程分解</h2><p>从编程的角度来看，发起一次系统调用和调用一个C函数无异，然而在这背后，一次系统调用包含了很多的步骤。为了清晰的说明整个流程，就以x86-32架构上的实现为例：</p><ol><li><p>应用程序通过调用C库(C Library)中的包装函数(wrapper function)，发起系统调用；</p></li><li><p>这个包装函数必须保证所有的参数对于系统调用是可用的，参数通过栈(Stack)<br>传递给包装函数，但是对于内核来说，需要它们存储在指定的寄存器内，此时包装函数会将这些参数拷贝到这些指定的寄存器内；</p></li><li><p>由于所有系统调用都是以同样的方式进入内核，内核需要用某种方式来区分这些不同的系统调用。因此，包装函数还会拷贝系统调用的数字标识到指定的CPU寄存器(<code>%eax</code>)中；</p></li><li><p>包装函数执行<code>trap</code>机器指令(<code>int 0x80</code>)，将处理器由用户态切换至内核态，并执行<code>0x80</code>位置的系统向量指向的代码；<br>（如今很多x86-32架构实现了<code>sysenter</code>指令，为用户态内核态切换提供了一种更快速的方式。<code>sysenter</code>的支持起始于2.6版本内核和glibc 2.3.2）</p></li><li><p>为了响应这一次调用，内核调用它的<code>system_call()</code>例程(<code>system_call()</code> routine)：<br> a) 将寄存器中的值保存在内核栈中<br> b) 检查系统调用数字标识的合法性<br> c) 根据内核变量<code>sys_call_table</code>找到对应的系统调用服务例程(service routine)。如果它包含了参数，则首先检查参数的合法性，然后继续执行必要的流程。比如修改参数中指定位置的值，并进行用户空间和内核空间的数据传递（I/O操作）。最后，服务例程向<code>system_call()</code>例程返回结果状态<br> d) 从内核栈中恢复寄存器中的值，并将系统调用返回值置入栈中<br> e) 返回到包装函数，并将处理器切换回用户态</p></li><li><p>如果系统调用服务例程(system call service routine)的返回值表示了一个异常(error)，则包装函数将全局变量<code>errno</code>设置为该值。然后包装函数将这个值返回给调用者，用于告知这次系统调用的状态是成功还是失败；</p></li></ol><p><img src="steps_of_a_system_call.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>The Linux Programming Interface [3.1 System Calls]</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时的内存管理</title>
      <link href="/2019/09/23/the-run-time-storage-organization/"/>
      <url>/2019/09/23/the-run-time-storage-organization/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇总结 <a href="./2019-09-22-the-garbage-collection-mechanism">垃圾回收入门</a> 中，我的本意是以了解垃圾回收相关概念为主，暂时忽略其他相关的概念。不过，这导致了有一些内容非常的模糊，容易引起疑惑。比如，是所有被创建的对象都需要回收吗？为什么在垃圾回收课题中会经常出现“堆区”的概念？对象在程序运行时到底是如何分配管理的？</p><p>对此，我又向前查找，阅读了《编译原理》第七章的1～4节，在这里再做一下简要总结，同时解答上面的几个疑惑。</p><h2 id="运行时刻环境"><a href="#运行时刻环境" class="headerlink" title="运行时刻环境"></a>运行时刻环境</h2><p>程序语言中包含很多抽象概念，比如：名字(names)、作用域(scopes)、绑定(bindings)、数据类型(data types)、操作符(operators)、过程(procedures)、参数(parameters)和控制流构造(flow-of-control constructs)。编译器为了实现在计算机上支持这些概念，使得程序可以成功运行，需要创建并管理一个<strong>运行时刻环境</strong>(run-time environment)。</p><p>这个环境需要处理的事务如下：</p><ul><li>为源程序中命名的对象分配空间、安排存储位置(the layout and allocation of storage locations for the objects named in the source program)</li><li>确定程序访问变量的机制(the mechanisms used by the target program to access variables)</li><li>过程间的连接(the linkages between procedures)</li><li>确定参数传递机制(the mechanisms for passing parameters)</li><li>实现对操作系统、输入/输出设备及其他程序的接口(the interfaces to the operating system, input/output devices, and other programs)</li></ul><p>这里只关注第一个问题：<strong>为对象分配空间、安排存储位置</strong></p><h2 id="存储组织-Storage-Organization"><a href="#存储组织-Storage-Organization" class="headerlink" title="存储组织(Storage Organization)"></a>存储组织(Storage Organization)</h2><p>程序在它的逻辑地址空间中运行，这个逻辑地址空间是由编译器、操作系统和计算机共同管理和组织的。</p><p>逻辑地址空间中的程序，在运行时刻的映像包含两部分：数据区(data areas)和代码区(program areas)。</p><p>某个语言在某个操作系统上，可能按照如下方式划分内存空间：</p><p> <img src="storage-organization.png" alt="内存空间划分"></p><p><em>为了使运行时刻的空间利用率最大化，设计令堆区和栈区的空间对向增长</em></p><p>具体的空间使用如下表格：</p><div class="table-container"><table><thead><tr><th>区域</th><th>空间</th><th>存储内容</th></tr></thead><tbody><tr><td>代码区</td><td>静态</td><td>生成的目标代码</td></tr><tr><td>静态区</td><td>静态</td><td>全局常量、一些编译器产生的数据</td></tr><tr><td>堆区</td><td>动态</td><td>具有长生命周期的数据、编译时不能确定大小的数据</td></tr><tr><td>栈区</td><td>动态</td><td>函数调用过程中产生的活动记录(activation records)</td></tr></tbody></table></div><p>这里就可以看到，需要考虑动态回收空间的只有数据会动态变化的堆区和栈区，那么为什么垃圾回收只面向堆区呢？这就要详细了解一下栈区的特点了。</p><h2 id="空间的栈式分配"><a href="#空间的栈式分配" class="headerlink" title="空间的栈式分配"></a>空间的栈式分配</h2><p>看到“栈”，就很容易联想到数据结构中的“栈”。总之，它们都是一种适用先入后出(First In, Last Out)场景的结构。</p><p>为了理解程序对空间的栈式分配，这里需要以函数的嵌套调用为例，同时引入一个概念：活动记录(activation records)。</p><p>首先，看这段使用递归的方式实现的快速排序算法。</p><p> <img src="quicksort.png" alt="quickSort"></p><p>我们可以使用简单的函数调用活动序列来描述它：</p><p> <img src="possible-activations.png" alt="possible activations"></p><p>接下来，把它完整递归过程抽象成一个树形结构，这个结构被称为<strong>活动树</strong>(Activation Tree)</p><p> <img src="activation-tree.png" alt="activation tree"></p><p>那么：</p><ul><li>函数的完整调用过程，和活动树的前序遍历对应</li><li>函数的完整返回过程，和活动树的后序遍历对应</li><li>某一次正在进行的函数调用，就对应活动树上的某一个结点。当前全部未结束（活跃的）的调用，就对应当前结点及其祖先节点；调用的顺序，就是从根结点到当前结点的路径；返回的路径，就是调用路径的反向。</li></ul><p>活动树中的每一个节点，都对应着一次函数调用的活动记录，它可能包含的数据如下图所示：</p><p> <img src="activation-record.png" alt="activation record"></p><p><em>图中最下方的位置是接近栈顶的位置，上方接近栈底</em></p><p>到这里，就可以看到，活动记录中，有一部分空间是分配给这一次函数调用的局部数据的。</p><p>整个嵌套调用流程的全部活动记录，是由一个称为<strong>控制栈</strong>(control stack)的运行时刻栈管理的。每一次函数调用的活动记录(activation record)，也可以被称为<strong>帧</strong>(frame)。</p><p>在进入某个函数时，其活动记录被压入栈顶；退出时，则相应的将其活动记录弹出栈顶，复用空间。在这个过程中，活动记录里的局部数据也随之消亡。</p><p> <img src="growing-stack.png" alt="growing stack"></p><p>因此，虽然很多时候，现代程序设计语言中，将无法在编译时刻确定大小的数据放在堆区。但是，当一个对象完整的生命周期都在这个过程(procedure)的局部空间中完成，在局部中创建，在过程(procedure)退出后不需要再进行访问，那么就可以为这个对象在栈区分配空间，同时也不必再考虑其失效后单独回收空间的问题。</p><p>这也就是垃圾回收只需要面向堆区的原因。</p><p>以上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>编译原理（第二版）[7.1～7.2]</p>]]></content>
      
      
      <categories>
          
          <category> Compilers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compilers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收(Garbage Collection)入门</title>
      <link href="/2019/09/21/the-garbage-collection-mechanism/"/>
      <url>/2019/09/21/the-garbage-collection-mechanism/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看《Concurrency in Go》的时候，突然开始思考垃圾回收的问题。想起之前在学习Python的时候，对垃圾回收机制也只是简单了解，网上博客的说法也不是很统一，所以这次决定系统地了解一下。查了网上的一些资料，最后追踪到《编译原理》（龙书）第7章，在这里稍微做一下整体的总结，不针对具体的编程语言。内容可能偏向表面概念，具体算法实现如果日后有精力深究，再去详细分析，这只是先从概念上入门理解。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="garbage（垃圾）"><a href="#garbage（垃圾）" class="headerlink" title="garbage（垃圾）"></a>garbage（垃圾）</h3><p><strong>不能被引用到数据通常被称为“垃圾(garbage)”</strong>。“能否被引用到”主要通过“可达性(reachability)”这一概念来进行描述。显然，只有两种状态可以用来描述一个对象：可达(reachable)或不可达(unreachable)。同时，一个对象被创建，状态由可达转变为不可达，一定是由用户程序操作的结果，这个用户程序，在垃圾回收这个论题中，通常被称为“增变者(mutator)”。当某些对象对于增变者来说不可达的时候，它们就转变为了垃圾。</p><h3 id="reachability（可达性）"><a href="#reachability（可达性）" class="headerlink" title="reachability（可达性）"></a>reachability（可达性）</h3><p><strong>可达性</strong>是基于跟踪的垃圾回收方式判断一个对象是否为垃圾的关键指标。可达(reachable)对象的集合随着程序的运行而改变。当新的对象被创建，这个集合就会增长；当某些对象变得不可达(unreachable)，这个集合就随之缩小。最重要的是，当一个对象变得不可达，它就不可能再次变得可达。</p><p>一个增变者(mutator)改变可达对象集合的方式有以下四种：</p><ul><li>对象创建（Object Allocations）</li><li>参数传递（Parameter Passing）和值的返回（Return Values）</li><li>引用赋值（Reference Assignments）</li><li>程序返回（Procedure Returns）</li></ul><p>前几项都比较容易理解，也很好想象出对应的场景，但最后一项还需要解释一下。Procedure，常常被翻译为“程序”或者“过程”，它和Program“程序”的主要区别在于，Program更多指的是一个完整的计算机程序，而Procedure指的是一段完成特定功能的程序片段。在这里的Procedure Returns可以理解成比如一次函数调用。当函数执行结束并返回的时候，函数调用栈(Stack)的栈帧(Frame)弹出，如果栈帧中保存了对某个对象唯一可达的引用，那么这个对象就此变为不可达。</p><p>寻找不可达对象有两种方法：</p><ol><li>截获一个对象由可达转变为不可达的时刻</li><li>周期性地检测所有对象的可达状态</li></ol><h3 id="type-safe（类型安全）"><a href="#type-safe（类型安全）" class="headerlink" title="type safe（类型安全）"></a>type safe（类型安全）</h3><p><strong>一种编程语言，如果它的任何数据组成部分的类型都是可以明确确定的，那么我们就说它是“类型安全(type safe)”的。</strong>类型安全的编程语言又可以分为两种：一种是数据类型可以在编译时确定的，这种被称为“静态类型语言(Statically Typed Language)”；另一种是数据类型在编译时无法确定，但可以在程序运行时确定的，被称为“动态类型语言(Dynamically Typed Language)”。<strong>类型安全是自动垃圾回收的基本条件。</strong>像C和C++，由于它们的存储地址可以支持任意操作，比如对指针进行算术运算，或将整型(Integer)转化为指针(pointer)，尽管它们的地位如此重要，但却并不适合应用自动垃圾回收机制。</p><p>在《编译原理》中，原文这样写道：<em>A language in which the type of any data component can be determined is said to be type safe. There are type-safe language like ML, for which we can determine types at compile time. There are other type-safe languages, like Java, whose types cannot be determined at compile time, but can be determined at run time. The latter are called dynamically typed languages.</em>  Java被描述为动态类型，这里仍然有些疑问，需要进一步了解。</p><h3 id="root-set（根集）"><a href="#root-set（根集）" class="headerlink" title="root set（根集）"></a>root set（根集）</h3><p>我们把程序可以直接操作，而不需要对指针解引用(dereference)的数据的集合，称为根集。根集中的对象，是程序在任意时刻都可以直接访问的。虽然定义中描述的是“不需要指针解引用就可以访问”，但是很多情况下，编译器优化会使得实际的根集并不完全符合定义中的条件，但我们仍将它视作根集。</p><h3 id="floating-garbage（漂浮垃圾）"><a href="#floating-garbage（漂浮垃圾）" class="headerlink" title="floating garbage（漂浮垃圾）"></a>floating garbage（漂浮垃圾）</h3><p>我们将每次垃圾回收之后被留下的垃圾，称为漂浮垃圾。这里当然不是说floating garbage会被永远的留下，由于垃圾回收会在程序运行的过程中根据条件多次触发，所以不需要每一次都做到完美回收全部垃圾，只要保证任何一次垃圾回收留下的漂浮垃圾，能在下一轮被回收，就不会产生内存泄漏的问题。</p><h2 id="垃圾回收的性能度量"><a href="#垃圾回收的性能度量" class="headerlink" title="垃圾回收的性能度量"></a>垃圾回收的性能度量</h2><ul><li>总体运行时间（Overall Execution Time）</li><li>空间使用（Space Usage）</li><li>暂停时间（Pause Time）</li><li>程序局部性（Program Locality）</li></ul><p>前三点可能看字面意思就很容易理解，第四点在这里还需要稍微解释一下。</p><p>在《编译原理》7.4.3节中，讲到了“程序的局部性(Locality in Programs)”。局部性分为两种：一个计算机程序，当它操作的存储位置在短时间内有很大几率<strong>再次</strong>被访问，我们就说它具有“<strong>时间局部性(temporal locality)</strong>”；当它操作的存储位置的<strong>临近空间</strong>有很大几率被访问到，我们就说它具有“<strong>空间局部性(spatial locality)</strong>”。程序的局部性对性能的影响，主要来自于现代计算机的层次存储结构与缓存策略的特性。</p><h2 id="垃圾回收方式分类"><a href="#垃圾回收方式分类" class="headerlink" title="垃圾回收方式分类"></a>垃圾回收方式分类</h2><ul><li>基于引用计数 (Reference Counting) 的垃圾回收</li><li>基于跟踪 (Trace-Based) 的垃圾回收<ul><li>基本的标记-清除回收（Basic Mark-and-Sweep Collection）</li><li>Baker优化的标记-清除回收（Baker’s Mark-and-Sweep Collection）</li><li>标记-压缩回收（Mark-and-Compact Collection）</li><li>拷贝回收（Copying Collection）</li></ul></li><li>短暂停顿(Short-Pause)的垃圾回收<ul><li>增量式回收（Incremental Collection）</li><li>部分回收（Partial Collection）<ul><li>分代垃圾回收（Generational Garbage Collection）</li><li>列车算法（Train Algorithm）</li></ul></li></ul></li></ul><p>以上是《编译原理》7.5～7.7章节的对于全部垃圾分类方式的介绍顺序和层级。乍一看这种分类的维度有点儿不太一致，前面根据判断对象是否为垃圾的方式划分，最后却又按照垃圾回收时的停顿时间分出了第三大类。根据我的理解，实际的分类维度可以有两个：</p><p>首先是最容易理解的，根据停顿的时长划分为</p><ul><li>全面停顿（Stop-the-World）的垃圾回收</li><li>短暂停顿（Short-Pause）的垃圾回收</li></ul><p>简单的基于跟踪的垃圾回收全都会导致程序的全面暂停，所以上面“基于跟踪的垃圾回收”全部都可以划分到STW类别。短暂停顿的垃圾回收除了上面原本的分类外，还可以把“基于引用计数的垃圾回收”划分到其中。这是因为基于引用计数的垃圾回收是可以以增量的方式进行的，它可以在不同的时间点进行逐步回收。具体的方式比如设定阈值，当不可达对象的数量到达阈值时触发回收。</p><p>然后，就是按照垃圾的判定查找方式划分为：</p><ul><li>基于引用计数（Reference Counting）的垃圾回收</li><li>基于跟踪（Trace-Based）的垃圾回收</li></ul><p>按照这种维度分类，再回头看上面的“短暂停顿的垃圾回收”，可以看出实际上所谓的“增量式回收”和“部分回收”只是对回收任务按照时间或空间进行了分割，使得垃圾回收的工作不再一次性完成一整轮，以此来优化程序整体的运行效果，使程序不再单次长时间地暂停，本质上的垃圾判定方式还是由具体实现决定的。</p><h2 id="垃圾回收方式详细总结"><a href="#垃圾回收方式详细总结" class="headerlink" title="垃圾回收方式详细总结"></a>垃圾回收方式详细总结</h2><p>这一部分介绍<strong>基于引用计数</strong>和<strong>基于跟踪</strong>两种垃圾回收方式的通用概念，然后简要对比几种不同的基于跟踪的垃圾回收算法。</p><h3 id="基于引用计数的垃圾回收"><a href="#基于引用计数的垃圾回收" class="headerlink" title="基于引用计数的垃圾回收"></a>基于引用计数的垃圾回收</h3><p>根据名字不难理解，这种垃圾回收方式，确定一个对象是否为垃圾，是根据外部对它的引用数来判断的。如果一个对象的引用数为0，显然它不再被需要，它就成为了待回收的垃圾。如果一个对象的引用数大于零，一般来说它之后还会继续被使用。那么这里有个特殊情况：假定存在两个或多个对象，在某种情况下它们产生了相互引用，或者分别被对方的子对象引用，此时如果也不存在任何来自外部的引用，那么显然它们需要被回收掉<em>（如果它们不是根集成员的话）</em>。但是，此时它们的引用计数不为0，基于引用计数的回收器无法判定它们为垃圾，如果没有其他方式辅助判断，就会产生内存泄漏。这就是<strong>循环引用(Cyclic References)</strong>的问题。</p><p>那么，引用计数方式的关键点是，什么时候计数会发生改变？有以下几种情况：</p><p><em>这里可以参照上文“可达性”的部分，对比着来理解</em></p><ul><li>对象创建（Object Allocation）—— 新对象的计数设置为 1</li><li>参数传递（Parameter Passing）—— 所有传入对象的计数 +1</li><li>引用赋值（Reference Assignments）—— 对于两个引用<code>u</code>和<code>v</code>，当执行语句<code>u = v</code>时，<code>u</code>原本引用的对象引用计数 -1，而<code>v</code>原本引用的对象引用计数 +1</li><li>程序返回（Procedure Returns）—— 同样的，以函数调用为例，当函数退出时，其中的局部对象引用计数均 -1，如果多个局部变量引用了同一个对象，那么这个对象的引用计数要减去相应的数量</li><li>可达性丢失的传递（Transitive Loss of Reachability）—— 当一个对象的引用计数为0，它内部引用的子对象的引用计数同时也需要 -1</li></ul><p>可以看出，以上几种会修改引用计数的场景，遍布整个程序的任何位置，可能发生在程序运行的任何时刻。因此，这带来了相应的优势和劣势：</p><p><strong>优势</strong>：</p><ul><li><strong>回收工作可以以增量的方式进行</strong>。由于引用计数的运算分布在整个程序中，因此不必一次完成过多的垃圾判定和回收工作，可以有效的切分任务，逐步完成。对于要求较强实时性的系统来说，引用计数无疑是一种很有吸引力的垃圾回收方式。</li><li><strong>垃圾可以及时回收</strong>。同样的，计数变更的及时性，也让回收工作可以更加及时进行，但这是在平衡回收效率和程序运行效率的情况下。</li></ul><p><strong>劣势</strong>：</p><ul><li><strong>整体开销较大</strong>。参照上面引用计数发生改变的几种情况，每一次引用赋值、程序片段的入口和出口处，都需要进行额外的计算，而且这些额外的计算遍布整个程序。同时，维护计数也需要额外的空间。</li></ul><h3 id="基于跟踪的垃圾回收"><a href="#基于跟踪的垃圾回收" class="headerlink" title="基于跟踪的垃圾回收"></a>基于跟踪的垃圾回收</h3><p>所有基于跟踪的垃圾回收算法，都需要计算可达对象集合，然后取其补集得到不可达对象，进行回收。因此，内存的使用流程可以归纳为以下几个步骤的循环：</p><ol><li>增变者或程序运行，并发出分配请求</li><li>垃圾回收器通过跟踪的方式揭示对象的可达性</li><li>垃圾回收器回收不可达对象的存储空间</li></ol><p>在以上几个步骤执行的过程中，对象或它们所占用的存储块(Chunks of Memory)会在以下几种状态之间变更：</p><ul><li>空闲（Free）</li><li>未访问（Unreached）</li><li>未扫描（Unscanned）</li><li>已扫描（Scanned）</li></ul><p><em>这些存储块的状态可能存储在其内部，也可能由垃圾回收算法中特定的数据结构存储</em></p><p>当不再有对象处于未扫描状态，可达性计算就完成了。此时仍然处于未访问状态的对象，就可以确定为不可达的。</p><p><img src="status.png" alt="status"></p><p>如果把对象之间的引用关系看作是图的结构，把对象看作顶点，把引用关系看作是有向边，那么整个跟踪标记的过程，实际可以看作是以根集为起点的图的遍历过程。</p><p>通过跟踪获得了可达对象和不可达对象的集合后，就可以根据具体的回收算法，对不可达对象（垃圾）进行回收了。不同算法间的差别在下面列举出来。</p><h3 id="不同回收算法的比较"><a href="#不同回收算法的比较" class="headerlink" title="不同回收算法的比较"></a>不同回收算法的比较</h3><h4 id="简单标记-清除-Basic-Mark-and-Sweep-算法"><a href="#简单标记-清除-Basic-Mark-and-Sweep-算法" class="headerlink" title="简单标记-清除 (Basic Mark-and-Sweep)算法"></a>简单标记-清除 (Basic Mark-and-Sweep)算法</h4><ol><li>通过跟踪找到全部可达对象，并对其进行标记</li><li>扫描全部存储区域，将不可达对象占用的存储空间回收</li></ol><p><img src="WechatIMG27.jpeg" alt="mark-and-sweep"></p><h4 id="标记-清除优化-Baker’s-Mark-and-Sweep-算法"><a href="#标记-清除优化-Baker’s-Mark-and-Sweep-算法" class="headerlink" title="标记-清除优化(Baker’s Mark-and-Sweep)算法"></a>标记-清除优化(Baker’s Mark-and-Sweep)算法</h4><ol><li>预先记录已分配对象的集合</li><li>通过跟踪标记所有可达对象</li><li>求已分配对象与可达对象集合的差集，得到不可达对象集合</li><li>回收不可达对象占用的空间</li></ol><p><em>这个优化版的算法，相比上面的简单版主要是减小了获取不可达对象时的开销</em></p><p><img src="baker&#39;s_mark-and-sweep.png" alt="baker&#39;s mark-and-sweep"></p><h4 id="标记-压缩-Mark-and-Compact-算法"><a href="#标记-压缩-Mark-and-Compact-算法" class="headerlink" title="标记-压缩(Mark-and-Compact)算法"></a>标记-压缩(Mark-and-Compact)算法</h4><ol><li>标记阶段，与标记-清除算法类似</li><li>扫描已分配的内存段，为每个可达对象计算新的位置地址</li><li>将可达对象拷贝到新的地址，更新它们的引用</li></ol><p><em>这个算法主要是减少了碎片的产生，降低了对内存使用的需求</em></p><p><img src="mark-and-compact.png" alt="mark-and-compact"></p><h4 id="拷贝回收-Copying-Collection-算法"><a href="#拷贝回收-Copying-Collection-算法" class="headerlink" title="拷贝回收(Copying Collection)算法"></a>拷贝回收(Copying Collection)算法</h4><p><em>这个算法需要将空闲空间分为A和B两个部分使用</em></p><ol><li>从A中找到所有可达对象，将它们拷贝到B</li><li>回收A的全部存储空间，因为此时A中只剩下不可达对象</li><li>两个空间角色对换</li></ol><p><em>这个算法的优势在于不需要考虑任何不可达对象，但同时，对于大型对象或存活周期较长的对象来说，反复拷贝的开销就很高了</em></p><p><img src="copying.png" alt="copying"></p><h2 id="垃圾回收策略详细总结"><a href="#垃圾回收策略详细总结" class="headerlink" title="垃圾回收策略详细总结"></a>垃圾回收策略详细总结</h2><p>直接单纯地使用基于跟踪的回收算法，每一轮回收都完整地进行，必然会导致程序频繁地全面暂停，这显然是不利的。因此，需要考虑切分一轮回收的工作量，逐步完成，使得每一次可以较短地暂停。同时还要考虑提升回收效率，尽量避免无效的或多余的重复操作。</p><h3 id="分代回收策略"><a href="#分代回收策略" class="headerlink" title="分代回收策略"></a>分代回收策略</h3><p>分代回收策略的设计来源于一个统计事实，约80%～98%的对象的存活周期都非常短，甚至在创建后等不到垃圾回收的启动就已经到达了生命的尽头。因此，高频地对新对象进行垃圾回收具有相当高的性价比。<br>于是，分代回收策略将存储区域分为 0，1，2，… n 世代，序号越小储存越年轻的对象。当0世代达到触发回收的条件时，回收0世代的所有垃圾，将存活下来的对象提升至1世代。当1世代进行回收时，再将存活下来的对象提升为2世代，依次类推。这个过程不断反复。</p><p>一般情况下，当对i世代的垃圾回收启动时，也会同时对所有小于i的世代进行回收工作。这样做的原因主要有以下两点：</p><ul><li>年轻的世代往往包含更多的垃圾，除了每次针对某个年轻世代进行回收外，再加上和较老的世代一起回收，可以获得更好的收效</li><li>当对世代i进行垃圾回收时，0～i的世代组成了目标集(Target Set)，序号大于i的世代组成了稳定集(Stable Set)。为了每次的部分回收找到根集，每个世代i都保持了一个记忆集(Remembered Set)，这个记忆集中保存了世代数大于i、同时对i世代对象存在引用的对象。按照这样的策略，每次部分回收的根集就可以看作是全部小于等于i世代记忆集的并集。那么每次回收完成，将不需要对记忆集进行更新。</li></ul><p><em>这里就有了一个疑问，到底在什么时候会去更新这个记忆集呢？ 这个问题暂时保留，关键词：写屏障(write barrier)</em></p><p>根据这种策略，一旦针对n世代的回收启动，那么实际就相当于对所有世代进行了一次完整的回收，这时候还是会导致程序全面暂停。那么 就需要考虑另外的办法来处理针对较较成熟对象的回收。这就要用到<strong>列车算法(Train Algorithm)</strong>。由于列车算法很少能够遇到，在这里也就不做详细的总结了，相关的内容可以阅读 <a href="http://oohcode.com/2017/02/03/gc-advanced/">垃圾回收算法进阶</a> 这篇文章。</p><h2 id="垃圾回收中的高级论题"><a href="#垃圾回收中的高级论题" class="headerlink" title="垃圾回收中的高级论题"></a>垃圾回收中的高级论题</h2><ul><li>并行和并发垃圾回收</li><li>类型不安全的语言的保守垃圾回收</li><li>弱引用（Weak References）</li></ul><p>这些内容在编译原理中并没有详细具体的介绍，在这里先列出来，如果有需要，再查找相关资料进行具体总结。</p><p>以上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>编译原理(第二版) [7.5～7.7]<br>Compilers - Principles, Techniques, &amp;Tools(Second Edition) [7.5～7.7]<br><a href="http://oohcode.com/2017/02/03/gc-advanced/">垃圾回收进阶算法</a><br><a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/">聊聊Python的内存管理</a><br><a href="https://cloud.tencent.com/developer/news/78317">Python和Ruby 的分代垃圾回收机制</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Compilers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Garbage Collection </tag>
            
            <tag> Compilers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asyncio vs gevent</title>
      <link href="/2019/07/05/python/asyncio-vs-gevent/"/>
      <url>/2019/07/05/python/asyncio-vs-gevent/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文列举了一些简单场景下的协程应用，主要目的是通过对比<code>asyncio</code>和<code>gevent</code>的API设计，加深对协程的理解，同时了解这两种协程实现在用法上的特点和差异。</p><h2 id="环境及版本"><a href="#环境及版本" class="headerlink" title="环境及版本"></a>环境及版本</h2><ul><li>Python 3.7</li></ul><h2 id="一、创建简单协程并发任务"><a href="#一、创建简单协程并发任务" class="headerlink" title="一、创建简单协程并发任务"></a>一、创建简单协程并发任务</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  使用asyncio完成简单协程并发任务</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            content = <span class="keyword">await</span> response.read()</span><br><span class="line">            <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">tasks = <span class="built_in">list</span>()</span><br><span class="line">url_list = [<span class="string">&quot;http://www.xxx.com&quot;</span>]*<span class="number">10</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    task = loop.create_task(download(url))</span><br><span class="line">    tasks.append(task)</span><br><span class="line">result = loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用gevent完成简单协程并发任务</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">with</span> requests.session() <span class="keyword">as</span> session:</span><br><span class="line">        response = session.get(url)</span><br><span class="line">        <span class="keyword">return</span> response.content</span><br><span class="line"></span><br><span class="line">tasks = <span class="built_in">list</span>()</span><br><span class="line">url_list = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    <span class="comment"># 创建greenlet</span></span><br><span class="line">    greenlet_coro = gevent.spawn(download, url)</span><br><span class="line">    tasks.append(greenlet_coro)</span><br><span class="line"><span class="comment"># 阻塞等待全部任务完成</span></span><br><span class="line">gevent.joinall(tasks)</span><br></pre></td></tr></table></figure><p>对比来看，在原生协程中，<code>await</code>语句声明了一个可以挂起当前协程的断点，异步等待一个<code>awaitable</code>对象，同时切换到其他可执行的协程，配合I/O多路复用实现了单线程的并发效果；而Gevent则是通过Monkey Patch，修改了<code>socket</code>的行为，将其转变为非阻塞模式，当然同样是以I/O多路复用为基础。对比来看，这两段简单代码的逻辑也是非常相似，只不过asyncio需要显式声明事件循环，而Gevent并不需要。<br>当然还有一点需要注意的是，<code>monkey.patch_all()</code>打上猴子补丁的位置是有讲究的，官方文档明确提到的，打补丁要在尽量靠前的位置，同时也要考虑并发编程时在什么位置更合适，不过实际的gevent实现的协程，代码的执行逻辑并不直观，还需要进行实际的测试才能更好的理解。</p><h2 id="二、Greenlet和Task方法对比"><a href="#二、Greenlet和Task方法对比" class="headerlink" title="二、Greenlet和Task方法对比"></a>二、<code>Greenlet</code>和<code>Task</code>方法对比</h2><h3 id="class-39-Task-39"><a href="#class-39-Task-39" class="headerlink" title="class &#39;Task&#39;"></a><code>class &#39;Task&#39;</code></h3><div class="table-container"><table><thead><tr><th>method</th><th>描述</th></tr></thead><tbody><tr><td><code>cancel()</code></td><td>取消协程,抛出<code>CancelledError</code>异常</td></tr><tr><td><code>cancelled()</code></td><td>task是否被取消</td></tr><tr><td><code>done()</code></td><td>task是否已完成</td></tr><tr><td><code>result()</code></td><td>返回协程中return的对象</td></tr><tr><td><code>exception()</code></td><td>返回task抛出的异常</td></tr><tr><td><code>add_done_callback(callback, *, context=None)</code></td><td>为task添加回调函数</td></tr><tr><td><code>remove_done_callback(callback)</code></td><td>移除task的回调函数</td></tr></tbody></table></div><p>这里推荐使用Python 3.7版本的asyncio并且阅读对应的官方标准库文档，3.7的文档重新整理了接口分类，指明了哪些是high level api，哪些是low level API，为使用提供了一些实际的指导。同时也修复了一些在3.6版本中显而易见的bug。</p><h3 id="class-39-Greenlet-39"><a href="#class-39-Greenlet-39" class="headerlink" title="class &#39;Greenlet&#39;"></a><code>class &#39;Greenlet&#39;</code></h3><div class="table-container"><table><thead><tr><th>method</th><th>描述</th></tr></thead><tbody><tr><td><code>ready()</code></td><td>greenlet是否执行完成</td></tr><tr><td><code>successful()</code></td><td>greenlet是否执行完成且没有抛出异常</td></tr><tr><td><code>start()</code></td><td>立即调度greenlet</td></tr><tr><td><code>start_later(seconds)</code></td><td>延时调度greenlet</td></tr><tr><td><code>join(timeout=None)</code></td><td>等待greenlet结束或超时</td></tr><tr><td><code>kill(exception=GreenletExit, block=True, timeout=None)</code></td><td>在greenlet中抛出异常</td></tr><tr><td><code>link(callback)</code></td><td>添加一个greenlet生命周期结束时的回调函数</td></tr><tr><td><code>link_value(callback)</code></td><td>添加一个greenlet完成，并正常返回时回调函数</td></tr><tr><td><code>link_exception(callback)</code></td><td>添加一个greenlet完成，并抛出异常的回调函数</td></tr><tr><td><code>rawlink(callback)</code></td><td>添加一个greenlet执行完成时的回调函数</td></tr><tr><td><code>unlink(callback)</code></td><td>移除<code>link()</code>或<code>rawlink()</code>添加的回调函数</td></tr></tbody></table></div><h2 id="二、gevent和asyncio协程调度函数对比"><a href="#二、gevent和asyncio协程调度函数对比" class="headerlink" title="二、gevent和asyncio协程调度函数对比"></a>二、<code>gevent</code>和<code>asyncio</code>协程调度函数对比</h2><h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a><code>asyncio</code></h3><div class="table-container"><table><thead><tr><th>function</th><th>描述</th></tr></thead><tbody><tr><td><code>run(coro, *, debug=False)</code></td><td>直接运行一个协程</td></tr><tr><td><code>create_task(coro)</code></td><td>创建一个Task实例，用于调度协程函数</td></tr><tr><td><code>sleep(delay, result=None, *, loop=None)</code></td><td>sleep</td></tr><tr><td><code>gather(*aws, loop=None, return_exceptions=False)</code></td><td>按照顺序并发调度多个awaitable对象，返回一个awaitable object</td></tr><tr><td><code>wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</code></td><td>并发调度awaitables,阻塞至满足return_when的条件，返回一个coroutine</td></tr><tr><td><code>wait_for(aw, timeout, *, loop=None)</code></td><td>等待一个awaitable完成或超时</td></tr><tr><td><code>as_completed(aws, *, loop=None, timeout=None)</code></td><td>并发执行awaitable objects，返回包含Future的迭代器</td></tr><tr><td><code>run_coroutine_threadsafe(coro, loop)</code></td><td>保证线程安全地执行一个协程</td></tr><tr><td><code>current_task(loop=None)</code></td><td>获得当前正在运行的task</td></tr><tr><td><code>all_tasks(loop=None)</code></td><td>获得事件循环中所有未完成的task</td></tr></tbody></table></div><p>由于<code>asyncio</code>需要显式声明事件循环，并把一部分功能交给了事件循环来做，所以这里把<code>loop</code>的一些涉及到协程调度的方法也列出来：</p><div class="table-container"><table><thead><tr><th>method</th><th>描述</th></tr></thead><tbody><tr><td><code>run_until_complete(future)</code></td><td>调度执行futurn，阻塞等待至其运行完成</td></tr><tr><td><code>call_soon(callback, *args, context=None)</code></td><td>在事件循环的下一轮中调度callback</td></tr><tr><td><code>call_later(delay, callback, *args, context=None)</code></td><td>延迟调度callback</td></tr><tr><td><code>create_task(coro)</code></td><td>创建一个Task实例，用于调度协程函数</td></tr></tbody></table></div><h3 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a><code>gevent</code></h3><div class="table-container"><table><thead><tr><th>funtion</th><th>描述</th></tr></thead><tbody><tr><td><code>spawn(function, *args, **kwargs)</code></td><td>创建一个greenlet对象，并调度它执行function</td></tr><tr><td><code>spawn_later(seconds, function, *args, **kwargs)</code></td><td>创建一个greenlet对象并延迟调度</td></tr><tr><td><code>spawn_raw(function, *args, **kwargs)</code></td><td>和<code>spawn</code>相似，详见文档描述</td></tr><tr><td><code>getcurrent()</code></td><td>获取当前正在执行的greenlet</td></tr><tr><td><code>kill(greenlet, exception=GreenletExit)</code></td><td>异步终止greenlet</td></tr><tr><td><code>killall(greenlets, exception=GreenletExit, block=True, timeout=None)</code></td><td>通过使greenlet抛出异常来强制终止所有greenlet</td></tr><tr><td><code>sleep(seconds=0, ref=True)</code></td><td>sleep</td></tr><tr><td><code>wait(objects=None, timeout=None, count=None)</code></td><td>等待一个object处于ready状态或事件循环结束</td></tr><tr><td><code>iwait(objects, timeout=None, count=None)</code></td><td>等待所有object就绪或到达超时事件，返回一个迭代器</td></tr><tr><td><code>joinall(greenlets, timeout=None, raise_error=False, count=None)</code></td><td>等待所有greenlet完成</td></tr></tbody></table></div><p>可以看到，整体来说，gevent和asyncio的api设计非常相似，同样的功能用它们两个都可以实现，只不过是代码风格上会有些差异。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asyncio </tag>
            
            <tag> Python </tag>
            
            <tag> Gevent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户级线程 与 内核级线程</title>
      <link href="/2019/02/12/linux/user-level-threads-and-kernel-level-threads/"/>
      <url>/2019/02/12/linux/user-level-threads-and-kernel-level-threads/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><!-- excerpt --><blockquote><p>原文: <a href="https://www.tutorialspoint.com/user-level-threads-and-kernel-level-threads">user-level-threads-and-kernel-level-threads [Alex Onsman] - 10th Oct, 2018</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文由作者Alex Onsman于2018-10-10发表在<a href="https://www.tutorialspoint.com/">Tutorialspoint</a>上，是对一个题为<a href="https://www.tutorialspoint.com/user-level-threads-and-kernel-level-threads">User-level threads and Kernel-level threads</a>的问题的回答。<br><br/></p><h2 id="原文翻译"><a href="#原文翻译" class="headerlink" title="原文翻译"></a>原文翻译</h2><p>线程(Thread)是一个可以被调度者独立管理的轻量级进程。它可以通过并行(Parallelism)的方式来提升应用(Application)的性能。</p><p>一个线程像数据段(Data Segment)、代码段文件(Code Segment Files)一样，和与其同级的线程共享信息，然而它拥有自己的寄存器(Registers)、栈(Stack)和计数器(Counter)等等。</p><p>线程的两个主要类别可以分为：<strong>用户级线程</strong> 和 <strong>内核级线程</strong>。如下图所示：</p><p><img src="1.PNG" alt="User-level threads and Kernel-level threads"></p><h3 id="用户级线程-User-Level-Threads"><a href="#用户级线程-User-Level-Threads" class="headerlink" title="用户级线程(User-Level Threads)"></a>用户级线程(User-Level Threads)</h3><p>用户级线程是由用户实现的，系统内核(Kernel)无法意识到它们的存在。对于系统内核来说，用户级线程就像一个单线程的进程一样。用户级线程比内核级线程更轻量(small)并且更快速(faster)，它由程序计数器(Program Counter, PC)、栈(Stack)、寄存器(Registers)和一个小的进程控制块(A Small Process Control Block)表示。并且，用户级线程间的同步(Synchronization)不会牵涉到内核。</p><h4 id="用户级线程的优点："><a href="#用户级线程的优点：" class="headerlink" title="用户级线程的优点："></a>用户级线程的优点：</h4><ol><li>用户级线程的创建比内核级线程更加容易和快速，并且更易于管理；</li><li>用户级线程可以在任何操作系统上运行；</li><li>用户级线程间的切换不会涉及到内核态的权限；</li></ol><h4 id="用户级线程的缺点："><a href="#用户级线程的缺点：" class="headerlink" title="用户级线程的缺点："></a>用户级线程的缺点：</h4><ol><li>用户级线程实现的多线程应用无法利用处理器的多个核心；</li><li>如果一个用户级线程被阻塞住，那么整个进程就将会阻塞住；</li></ol><h3 id="内核级线程-Kernel-Level-Threads"><a href="#内核级线程-Kernel-Level-Threads" class="headerlink" title="内核级线程(Kernel-Level Threads)"></a>内核级线程(Kernel-Level Threads)</h3><p>内核级线程直接由内核进行使用和管理。整个进程以及其中线程的上下文信息也由内核进行管理。因此，内核级线程相比之下要慢于用户级线程。</p><h4 id="内核级线程的优点："><a href="#内核级线程的优点：" class="headerlink" title="内核级线程的优点："></a>内核级线程的优点：</h4><ol><li>同一个进程的多个内核级线程可以被不同的处理器核心调度；</li><li>内核例程(Kernel Routines)同样可以是多线程的；</li><li>如果一个内核级线程产生了阻塞，同一个进程中的其他线程仍然可以被内核调度；</li></ol><h4 id="内核级线程的缺点："><a href="#内核级线程的缺点：" class="headerlink" title="内核级线程的缺点："></a>内核级线程的缺点：</h4><ol><li>进程中的线程切换需要切换到内核态；</li><li>内核级线程的创建和管理相较于用户级线程更慢；<br><br/></li></ol><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p>A thread is a lightweight process that can be managed independently by a scheduler. It improves the application performance using parallelism.</p><p>A thread shares information like data segment, code segment files etc. with its peer threads while it contains its own registers, stack, counter etc.</p><p>The two main types of threads are user-level threads and kernel-level threads. A diagram that demonstrates these is as follows:</p><p><img src="1.PNG" alt="User-level threads and Kernel-level threads"></p><h3 id="User-Level-Threads"><a href="#User-Level-Threads" class="headerlink" title="User - Level Threads"></a>User - Level Threads</h3><p>The user-level threads are implemented by users and the kernel is not aware of the existence of these threads. It handles them as if they were single-threaded processes. User-level threads are small and much faster than kernel level threads. They are represented by a program counter(PC), stack, registers and a small process control block. Also, there is no kernel involvement in synchronization for user-level threads.</p><h4 id="Advantages-of-User-Level-Threads"><a href="#Advantages-of-User-Level-Threads" class="headerlink" title="Advantages of User-Level Threads"></a>Advantages of User-Level Threads</h4><p>Some of the advantages of user-level threads are as follows:</p><ol><li>User-level threads are easier and faster to create than kernel-level threads. They can also be more easily managed.</li><li>User-level threads can be run on any operating system.</li><li>There are no kernel mode privileges required for thread switching in user-level threads.  </li></ol><h4 id="Disadvantages-of-User-Level-Threads"><a href="#Disadvantages-of-User-Level-Threads" class="headerlink" title="Disadvantages of User-Level Threads"></a>Disadvantages of User-Level Threads</h4><p>Some of the disadvantages of user-level threads are as follows:</p><ol><li>Multithreaded applications in user-level threads cannot use multiprocessing to their advantage.</li><li>The entire process is blocked if one user-level thread performs blocking operation.  </li></ol><h3 id="Kernel-Level-Threads"><a href="#Kernel-Level-Threads" class="headerlink" title="Kernel-Level Threads"></a>Kernel-Level Threads</h3><p>Kernel-level threads are handled by the operating system directly and the thread management is done by the kernel. The context information for the process as well as the process threads is all managed by the kernel. Because of this, kernel-level threads are slower than user-level threads.</p><h4 id="Advantages-of-Kernel-Level-Threads"><a href="#Advantages-of-Kernel-Level-Threads" class="headerlink" title="Advantages of Kernel-Level Threads"></a>Advantages of Kernel-Level Threads</h4><p>Some of the advantages of kernel-level threads are as follows:</p><ol><li>Multiple threads of the same process can be scheduled on different processors in kernel-level threads.</li><li>The kernel routines can also be multithreaded.</li><li>If a kernel-level thread is blocked, another thread of the same process can be scheduled by the kernel.  </li></ol><h4 id="Disadvantages-of-Kernel-Level-Threads"><a href="#Disadvantages-of-Kernel-Level-Threads" class="headerlink" title="Disadvantages of Kernel-Level Threads"></a>Disadvantages of Kernel-Level Threads</h4><p>Some of the disadvantages of kernel-level threads are as follows:</p><ol><li>A mode switch to kernel mode is required to transfer control from one thread to another in a process.</li><li>Kernel-level threads are slower to create as well as manage as compared to user-level threads.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
